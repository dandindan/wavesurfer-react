# Project Files Review
# Generated: 2025-06-10T05-48-37.828Z
# Total files: 18


================================================================================
File: implemetation guide.md
================================================================================

# How to Implement the WaveSurfer React Solution

This guide will help you implement the WaveSurfer visualization with the official `@wavesurfer/react` hook, which will solve the initialization and cleanup issues you've been experiencing.

## Step 1: Update package.json and install dependencies

1. Replace your `package.json` with the updated version that includes `@wavesurfer/react` and `wavesurfer.js`:

```json
{
  "name": "wavesurfer-react",
  "version": "1.0.0",
  "description": "WaveSurfer with Regions - React Implementation",
  "private": true,
  "dependencies": {
    "@wavesurfer/react": "^1.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "wavesurfer.js": "^7.9.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

2. Install the dependencies:

```bash
npm install
```

## Step 2: Update the components

1. Replace your `src/components/WaveSurferComponent.js` with the new version that uses `@wavesurfer/react`
2. Replace your `src/App.js` with the updated version
3. Keep your existing `src/components/StatusBar.js` and `src/components/UploadPanel.js` as they are
4. Keep your CSS files as they are

## Step 3: Remove script tags from index.html (optional)

Since we're now loading WaveSurfer.js through npm, you can remove the script tags from `public/index.html` if you want:

```html

```

Keeping them won't cause any issues, but they're redundant now.

## Step 4: Start the development server

```bash
npm start
```

## Why This Works Better

The `@wavesurfer/react` library is the official React integration for WaveSurfer.js, and it handles:

1. Proper initialization and cleanup of WaveSurfer.js instances
2. React lifecycle integration
3. Preventing memory leaks
4. Managing dependencies correctly

It gives us all the power of the original WaveSurfer.js library but handles the React-specific integration challenges automatically.

## Features Preserved from the Original HTML

This implementation maintains all the key features from your original HTML implementation:

- Waveform visualization
- Spectrogram
- Timeline
- Regions (creating by dragging, clicking to play)
- Minimap navigation
- Zoom controls
- Playback speed controls
- Region looping

The user interface and styling are also maintained to match your original implementation.


================================================================================
File: package.json
================================================================================

{
  "name": "wavesurfer-react",
  "version": "1.0.0",
  "description": "WaveSurfer with Regions - React Implementation",
  "private": true,
  "proxy": "http://localhost:3001",
  "dependencies": {
    "@wavesurfer/react": "^1.0.4",
    "body-parser": "^2.2.0",
    "cors": "^2.8.5",
    "express": "^5.1.0",
    "multer": "^1.4.5-lts.2",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "wavesurfer.js": "^7.9.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "server": "node server/server.js",
    "dev": "concurrently \"npm run server\" \"npm run start\""
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "concurrently": "^9.1.2"
  }
}


================================================================================
File: public/disable-websocket.js
================================================================================

/**
 * File: public/disable-websocket.js
 * Description: Disable WebSocket connection errors in development
 * 
 * Version History:
 * v1.0.0 (2025-05-21) - Initial implementation to suppress WebSocket errors - Maoz Lahav
 * v1.0.1 (2025-05-21) - Fixed process undefined error - Maoz Lahav
 */

// Suppress WebSocket connection errors (works in browser environment)
(function() {
  // Override console.error to filter out WebSocket errors
  const originalConsoleError = console.error;
  console.error = function(...args) {
    // Check if the error message contains WebSocket connection failure
    const errorMessage = args.join(' ');
    if (errorMessage.includes('WebSocket connection') && errorMessage.includes('failed')) {
      // Suppress this specific error
      return;
    }
    // Call the original console.error for other errors
    originalConsoleError.apply(console, args);
  };
})();

================================================================================
File: public/index.html
================================================================================

<!-- 
  File: public/index.html 
  Description: HTML entry point for the React application
  
  Version History:
  v1.0.0 (2025-05-18) - Initial implementation
  v1.0.1 (2025-05-18) - Added WaveSurfer scripts directly in HTML
  v1.0.2 (2025-05-21) - Added WebSocket error suppression - Maoz Lahav
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="WaveSurfer with Regions - React Implementation"
    />
    <title>WaveSurfer with Regions</title>

    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
      integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm"
      crossorigin="anonymous"
    />

    <!-- WaveSurfer and plugins -->
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/wavesurfer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/spectrogram.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/timeline.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/hover.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/minimap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/regions.min.js"></script>

    <!-- WebSocket error suppression for development -->
    <script src="%PUBLIC_URL%/disable-websocket.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      The React app will be mounted to the div with id="root".
    -->
  </body>
</html>


================================================================================
File: README.md
================================================================================

# WaveSurfer with Regions and VLC Player Integration

## Overview

This project integrates WaveSurfer.js audio visualization with VLC media player control. It provides:

1. Audio waveform visualization with WaveSurfer.js
2. Region selection and manipulation
3. VLC media player control via a web interface
4. Synchronization between WaveSurfer regions and VLC playback

The application allows users to visualize audio files, create regions by dragging on the waveform, and control VLC media player directly from the web interface.

## Features

- **Audio Visualization**: Display waveform and spectrogram
- **Region Management**: Create, edit, and remove regions on the waveform
- **VLC Integration**: Launch and control VLC from the web interface
- **Synchronization**: Click on a region to seek VLC to that position
- **Responsive Design**: Works on desktop and mobile devices

## Setup Instructions

### Prerequisites

- Node.js and npm installed
- VLC media player installed on your system
- React development environment

### Installation

1. Clone the repository:

   ```bash
   git clone <repository-url>
   cd wavesurfer-vlc-integration
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Install required packages:
   ```bash
   npm install @wavesurfer/react wavesurfer.js express body-parser
   ```

### Setup Backend for VLC Control

Create a server directory and add the backend files:

1. **Create Express server**:

   ```bash
   mkdir -p server
   cp src/backend-vlc-controller.js server/vlcController.js
   ```

2. **Create server.js file**:

   ```javascript
   const express = require('express');
   const bodyParser = require('body-parser');
   const vlcController = require('./vlcController');

   const app = express();
   const PORT = process.env.PORT || 3001;

   app.use(bodyParser.json());
   app.use('/api', vlcController);

   app.listen(PORT, () => {
     console.log(`Server running on port ${PORT}`);
   });
   ```

3. **Update package.json** to include server:
   ```json
   "scripts": {
     "start": "react-scripts start",
     "build": "react-scripts build",
     "server": "node server/server.js",
     "dev": "concurrently \"npm run server\" \"npm run start\""
   }
   ```

### Running the Application

1. Start the development environment:

   ```bash
   npm run dev
   ```

2. Access the application at http://localhost:3000

## Usage

1. **Upload an audio file** using the upload panel
2. **Visualize the audio** in the waveform and spectrogram
3. **Create regions** by dragging on the waveform
4. **Launch VLC** using the VLC button in the controls
5. **Control playback** using both WaveSurfer and VLC controls
6. **Click on regions** to seek VLC to that position

## Components Structure

- **App.js**: Main application component
- **WaveSurferComponent.js**: Audio visualization and region management
- **VLCController.js**: VLC media player control interface
- **UploadPanel.js**: File upload interface
- **StatusBar.js**: Application status display

## VLC Integration

The application communicates with VLC using its RC (Remote Control) interface. When you launch VLC from the web interface, it starts with the following parameters:

```
--extraintf rc --rc-host localhost:9999 --no-video-title-show
```

The backend server then communicates with VLC through this RC interface to control playback, seek to specific positions, adjust volume, etc.

## Customization

- Update the color scheme in CSS files
- Adjust the WaveSurfer visualization parameters in WaveSurferComponent.js
- Modify the VLC controller commands in VLCController.js
- Change the layout in App.js

## Credits

- WaveSurfer.js: https://wavesurfer-js.org/
- VLC Media Player: https://www.videolan.org/
- React: https://reactjs.org/

## License

MIT License


================================================================================
File: scan_project.js
================================================================================

/**
 * File: scan_project.js
 * Description: Script to scan all project files and output their contents for review
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 */

const fs = require('fs');
const path = require('path');

// Directories to exclude
const excludeDirs = ['node_modules', '.git', 'build', 'dist'];

// Files to exclude
const excludeFiles = ['.DS_Store', '.gitignore', 'package-lock.json'];

// File extensions to include
const includeExtensions = ['.js', '.jsx', '.html', '.css', '.json', '.md'];

// Configuration
const outputFile = 'project_files_review.txt';
const startDir = '.'; // Current directory

// Helper function to check if a file should be included
function shouldIncludeFile(filePath) {
  const fileName = path.basename(filePath);
  
  // Skip excluded files
  if (excludeFiles.includes(fileName)) {
    return false;
  }
  
  // Check file extension
  const ext = path.extname(filePath).toLowerCase();
  if (!includeExtensions.includes(ext)) {
    return false;
  }
  
  return true;
}

// Helper function to scan a directory recursively
function scanDirectory(dir, output) {
  try {
    // Read directory contents
    const items = fs.readdirSync(dir);
    
    // Process each item
    for (const item of items) {
      const itemPath = path.join(dir, item);
      const stat = fs.statSync(itemPath);
      
      // Process directories
      if (stat.isDirectory()) {
        // Skip excluded directories
        if (excludeDirs.includes(item)) {
          continue;
        }
        
        // Recursively scan subdirectories
        scanDirectory(itemPath, output);
      } 
      // Process files
      else if (stat.isFile() && shouldIncludeFile(itemPath)) {
        // Read file content
        const content = fs.readFileSync(itemPath, 'utf8');
        
        // Add to output
        output.push({
          path: itemPath,
          content: content
        });
      }
    }
  } catch (error) {
    console.error(`Error scanning directory ${dir}:`, error);
  }
}

// Main function
function main() {
  // Get current date and time
  const now = new Date().toISOString().replace(/:/g, '-');
  
  console.log(`Starting project scan at: ${now}`);
  console.log(`Output will be saved to: ${outputFile}`);
  
  // Collect all files
  const files = [];
  scanDirectory(startDir, files);
  
  // Sort files by path
  files.sort((a, b) => a.path.localeCompare(b.path));
  
  // Create output
  let output = `# Project Files Review\n`;
  output += `# Generated: ${now}\n`;
  output += `# Total files: ${files.length}\n\n`;
  
  // Add each file
  files.forEach((file, index) => {
    output += `\n${'='.repeat(80)}\n`;
    output += `File: ${file.path}\n`;
    output += `${'='.repeat(80)}\n\n`;
    output += file.content;
    output += '\n';
  });
  
  // Write output to file
  fs.writeFileSync(outputFile, output);
  
  console.log(`Scan complete. Found ${files.length} files.`);
  console.log(`Output saved to: ${outputFile}`);
}

// Run the script
main();

================================================================================
File: server/server.js
================================================================================

// server/server.js
const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const vlcController = require('./vlcController');

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Enable CORS for development
app.use(cors());

// Use VLC controller routes
app.use('/api', vlcController);

// Simple test route
app.get('/ping', (req, res) => {
  res.json({ message: 'VLC Control Server is running!' });
});

// Start server
app.listen(PORT, () => {
  console.log(`VLC Control Server running on port ${PORT}`);
  console.log(`Test the server: http://localhost:${PORT}/ping`);
});

================================================================================
File: server/vlcController.js
================================================================================

// server/vlcController.js
const express = require('express');
const { spawn } = require('child_process');
const net = require('net');
const fs = require('fs');
const path = require('path');
const os = require('os');
const multer = require('multer');
const router = express.Router();

// Set up file upload storage
const storage = multer.diskStorage({
  destination: function(req, file, cb) {
    cb(null, 'server/uploads/');
  },
  filename: function(req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname);
  }
});

const upload = multer({ storage: storage });

// Global variables to store state
let vlcProcess = null;
let isPlaying = false;
let currentMediaPath = null;

// VLC RC interface details
const VLC_HOST = 'localhost';
const VLC_PORT = 9999;

// Function to send command to VLC
const sendVLCCommand = async (command) => {
  return new Promise((resolve, reject) => {
    try {
      const client = new net.Socket();
      
      client.on('error', (err) => {
        reject(`Connection error: ${err.message}`);
      });
      
      client.connect(VLC_PORT, VLC_HOST, () => {
        client.write(`${command}\n`);
      });
      
      client.on('data', (data) => {
        const response = data.toString().trim();
        client.destroy();
        resolve(response);
      });
      
      // Set timeout to avoid hanging
      setTimeout(() => {
        client.destroy();
        reject('Connection timeout');
      }, 3000);
      
    } catch (error) {
      reject(`Error sending command: ${error.message}`);
    }
  });
};

// API endpoint for file upload
router.post('/upload', upload.single('file'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ 
        success: false, 
        message: 'No file provided' 
      });
    }
    
    const filePath = path.resolve(req.file.path);
    
    res.json({
      success: true,
      filePath,
      fileName: req.file.originalname,
      message: 'File uploaded successfully'
    });
  } catch (error) {
    console.error(`Error uploading file: ${error.message}`);
    res.status(500).json({
      success: false,
      message: `Error uploading file: ${error.message}`
    });
  }
});

// API endpoint for launching VLC
router.post('/launch-vlc', async (req, res) => {
  try {
    const { mediaPath } = req.body;
    
    // Validate media path
    if (!mediaPath || !fs.existsSync(mediaPath)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid media path or file not found' 
      });
    }
    
    // Kill any existing VLC process
    if (vlcProcess !== null) {
      try {
        vlcProcess.kill();
        // Wait for process to terminate
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Error terminating VLC process: ${error.message}`);
      }
    }
    
    // Determine VLC path based on OS
    let vlcPath;
    if (process.platform === 'win32') {  // Windows
      const windowsPaths = [
        'C:\\Program Files\\VideoLAN\\VLC\\vlc.exe',
        'C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe'
      ];
      
      for (const pathToCheck of windowsPaths) {
        if (fs.existsSync(pathToCheck)) {
          vlcPath = pathToCheck;
          break;
        }
      }
      
      if (!vlcPath) vlcPath = 'vlc';  // Try using PATH
    } else if (process.platform === 'darwin') {  // macOS
      if (fs.existsSync('/Applications/VLC.app/Contents/MacOS/VLC')) {
        vlcPath = '/Applications/VLC.app/Contents/MacOS/VLC';
      } else {
        vlcPath = 'vlc';  // Try using PATH
      }
    } else {  // Linux
      vlcPath = 'vlc';  // Try using PATH
    }
    
    console.log(`Launching VLC with path: ${vlcPath} for file: ${mediaPath}`);
    
    // Launch VLC with RC interface
    vlcProcess = spawn(vlcPath, [
      '--extraintf', 'rc',
      '--rc-host', `${VLC_HOST}:${VLC_PORT}`,
      '--no-video-title-show',  // No title overlay
      mediaPath
    ]);
    
    // Handle process events
    vlcProcess.on('error', (error) => {
      console.error(`VLC process error: ${error.message}`);
      vlcProcess = null;
    });
    
    vlcProcess.on('exit', (code) => {
      console.log(`VLC process exited with code ${code}`);
      vlcProcess = null;
    });
    
    // Log stdout and stderr
    vlcProcess.stdout.on('data', (data) => {
      console.log(`VLC stdout: ${data}`);
    });
    
    vlcProcess.stderr.on('data', (data) => {
      console.log(`VLC stderr: ${data}`);
    });
    
    // Wait for VLC to initialize
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Immediately pause
    await sendVLCCommand('pause');
    isPlaying = false;
    currentMediaPath = mediaPath;
    
    res.json({ 
      success: true, 
      message: 'VLC launched successfully' 
    });
    
  } catch (error) {
    console.error(`Error launching VLC: ${error.message}`);
    res.status(500).json({ 
      success: false, 
      message: `Error launching VLC: ${error.message}` 
    });
  }
});

// API endpoint for sending commands to VLC
router.post('/vlc-command', async (req, res) => {
  try {
    const { command } = req.body;
    
    if (!command) {
      return res.status(400).json({ 
        success: false, 
        message: 'No command provided' 
      });
    }
    
    if (!vlcProcess) {
      return res.status(400).json({ 
        success: false, 
        message: 'VLC is not running' 
      });
    }
    
    const response = await sendVLCCommand(command);
    
    // Update state based on command
    if (command === 'pause') {
      isPlaying = !isPlaying;
    } else if (command === 'stop' || command.startsWith('seek 0')) {
      isPlaying = false;
    } else if (command === 'play') {
      isPlaying = true;
    }
    
    res.json({ 
      success: true, 
      response,
      playerState: {
        isPlaying,
        currentMediaPath
      }
    });
    
  } catch (error) {
    console.error(`Error sending command to VLC: ${error.message}`);
    res.status(500).json({ 
      success: false, 
      message: `Error sending command: ${error.message}` 
    });
  }
});

// API endpoint for checking VLC status
router.get('/vlc-status', (req, res) => {
  res.json({
    isRunning: vlcProcess !== null,
    isPlaying,
    currentMediaPath
  });
});

module.exports = router;

================================================================================
File: src/app.js
================================================================================

/**
 * File: src/App.js
 * Description: Main application component with integrated controls
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation based on original HTML
 * v1.0.1 (2025-05-19) - Updated to use @wavesurfer/react
 * v1.0.2 (2025-05-19) - Removed loop regions checkbox, set loopRegions to true
 * v1.0.3 (2025-05-19) - Integrated VLC controller with all controls in one row
 * v1.0.4 (2025-05-21) - Fixed infinite update loop in file handling - Maoz Lahav
 * v1.0.5 (2025-05-27) - Fixed VLC file passing - now passes File object instead of blob URL - Maoz Lahav
 */

import React, { useState, useRef, useEffect } from 'react';
import WaveSurferComponent from './components/WaveSurferComponent';
import VLCController from './components/VLCController';
import StatusBar from './components/StatusBar';
import UploadPanel from './components/UploadPanel';
import './assets/styles/main.css';
import './assets/styles/integrated-controls.css';

function App() {
  // State
  const [audioFile, setAudioFile] = useState(null); // For WaveSurfer (blob URL)
  const [originalFile, setOriginalFile] = useState(null); // For VLC (File object)
  const [fileIdentifier, setFileIdentifier] = useState(null); // Added to track unique files
  const [isPlaying, setIsPlaying] = useState(false);
  const [fileName, setFileName] = useState("");
  const [isReady, setIsReady] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(100);
  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);
  const [waveSurferMuted, setWaveSurferMuted] = useState(false); // Mute WaveSurfer audio
  // Set loopRegions to true - regions will always loop
  const loopRegions = true;
  const [status, setStatus] = useState({ text: "No audio loaded", type: "info" });
  const [alert, setAlert] = useState({ message: "", isOpen: false, type: "info" });
  const [activeRegion, setActiveRegion] = useState(null);
  
  // Refs
  const wavesurferRef = useRef(null);
  
  // Handler for file uploads
  const handleFileUpload = (file) => {
    if (!file) return;
    
    console.log("App: File uploaded:", file.name);
    
    // Create a unique identifier for the file to avoid re-processing the same file
    const newFileIdentifier = file instanceof File 
      ? `${file.name}-${file.size}-${file.lastModified}`
      : file;
    
    // Only update if this is a different file
    if (newFileIdentifier !== fileIdentifier) {
      setFileIdentifier(newFileIdentifier);
      
      // Store the original File object for VLC
      setOriginalFile(file);
      
      // Create blob URL for WaveSurfer
      if (file instanceof File) {
        const url = URL.createObjectURL(file);
        setAudioFile(url);
        setFileName(file.name);
        console.log("App: Created blob URL for WaveSurfer:", url);
        console.log("App: Stored original File object for VLC:", file.name);
      } else {
        // If it's already a URL, use it for both
        setAudioFile(file);
        setOriginalFile(file);
        setFileName(String(file));
      }
      
      setIsPlaying(false);
      setIsReady(false);
      setStatus({ text: "Loading...", type: "warning" });
      setAlert({ message: `File loaded: ${file instanceof File ? file.name : 'Audio file'}`, isOpen: true, type: "success" });
    }
  };
  
  // Enhanced handler for play/pause with VLC sync
  const handlePlayPause = (isCurrentlyPlaying) => {
    console.log("ðŸŽµ App: Play/Pause triggered");
    
    // If isCurrentlyPlaying is provided, use it, otherwise toggle
    const newPlayingState = isCurrentlyPlaying !== undefined ? isCurrentlyPlaying : !isPlaying;
    setIsPlaying(newPlayingState);
    
    // Show user feedback
    setAlert({
      message: newPlayingState ? "Playing (WaveSurfer + VLC synced)" : "Paused (WaveSurfer + VLC synced)",
      isOpen: true,
      type: "info"
    });
    
    console.log(`ðŸŽµ App: Setting play state to ${newPlayingState}`);
  };
  
  // Handler for WaveSurfer ready event
  const handleReady = (wavesurfer) => {
    wavesurferRef.current = wavesurfer;
    setIsReady(true);
    setStatus({ text: `Loaded: ${fileName}`, type: "success" });
    
    // Apply mute state if WaveSurfer was muted before audio loaded
    if (waveSurferMuted) {
      try {
        wavesurfer.setVolume(0);
      } catch (error) {
        console.error("Error applying mute on ready:", error);
      }
    }
  };
  
  // Handler for zoom in
  const handleZoomIn = () => {
    const newZoom = Math.min(1000, zoomLevel + 50);
    setZoomLevel(newZoom);
  };
  
  // Handler for zoom out
  const handleZoomOut = () => {
    const newZoom = Math.max(10, zoomLevel - 50);
    setZoomLevel(newZoom);
  };
  
  // Handler for reset zoom
  const handleResetZoom = () => {
    setZoomLevel(100);
  };
  
  // Handler for mute/unmute WaveSurfer
  const handleToggleWaveSurferMute = () => {
    const newMutedState = !waveSurferMuted;
    setWaveSurferMuted(newMutedState);
    
    // Apply mute to WaveSurfer instance if available
    if (wavesurferRef.current) {
      try {
        if (newMutedState) {
          wavesurferRef.current.setVolume(0);
        } else {
          wavesurferRef.current.setVolume(1);
        }
        
        setAlert({
          message: newMutedState ? "WaveSurfer audio muted (VLC audio still active)" : "WaveSurfer audio unmuted",
          isOpen: true,
          type: "info"
        });
      } catch (error) {
        console.error("Error toggling WaveSurfer mute:", error);
      }
    }
  };
  
  // Handler for clear regions
  const handleClearRegions = () => {
    if (!wavesurferRef.current) {
      console.error("WaveSurfer instance not available");
      setAlert({ message: "Cannot clear regions: Player not initialized", isOpen: true, type: "danger" });
      return;
    }
    
    try {
      console.log("Attempting to clear regions...");
      
      // Try direct access to clearAllRegions method we added
      if (typeof wavesurferRef.current.clearAllRegions === 'function') {
        const result = wavesurferRef.current.clearAllRegions();
        if (result) {
          setAlert({ message: "All regions cleared", isOpen: true, type: "success" });
          // Reset active region
          setActiveRegion(null);
          return;
        }
      }
      
      // Try direct access to regions plugin
      if (wavesurferRef.current.regions) {
        console.log("Found regions plugin:", wavesurferRef.current.regions);
        wavesurferRef.current.regions.clearRegions();
        setAlert({ message: "All regions cleared", isOpen: true, type: "success" });
        // Reset active region
        setActiveRegion(null);
      } else {
        // Try to find the regions plugin in active plugins
        const regionsPlugin = wavesurferRef.current.getActivePlugins()?.find(
          plugin => plugin.name === 'regions' || plugin.params?.name === 'regions'
        );
        
        if (regionsPlugin) {
          console.log("Found regions plugin:", regionsPlugin);
          regionsPlugin.clearRegions();
          setAlert({ message: "All regions cleared", isOpen: true, type: "success" });
          // Reset active region
          setActiveRegion(null);
        } else {
          console.error("Regions plugin not found");
          setAlert({ message: "Could not clear regions", isOpen: true, type: "danger" });
        }
      }
    } catch (error) {
      console.error("Error clearing regions:", error);
      setAlert({ message: "Error clearing regions", isOpen: true, type: "danger" });
    }
  };
  
  // Handler for region activation
  const handleRegionActivated = (region) => {
    console.log("App: Region activated:", region);
    
    if (region.isClickPosition) {
      // This is a click position, not an actual region
      console.log(`App: Waveform clicked at ${region.start}s`);
      // Don't set this as activeRegion since it's just a click position
      setAlert({
        message: `Seeking to ${region.start.toFixed(2)}s`,
        isOpen: true,
        type: "info"
      });
    } else {
      // This is an actual region
      setActiveRegion(region);
    }
  };
  
  // Handler for VLC status changes
  const handleVLCStatusChange = (vlcStatus) => {
    // Synchronize WaveSurfer playback with VLC if needed
    if (vlcStatus.isPlaying !== isPlaying) {
      setIsPlaying(vlcStatus.isPlaying);
    }
  };
  
  // Handler for VLC errors
  const handleVLCError = (error) => {
    setAlert({ message: error, isOpen: true, type: "danger" });
  };
  
  // Handler for VLC region playback
  const handleVLCRegionPlayback = (data) => {
    console.log("App: VLC playing region:", data);
    // Could add more handlers here if needed
  };
  
  // Close alert after 3 seconds
  useEffect(() => {
    if (alert.isOpen) {
      const timer = setTimeout(() => {
        setAlert(prev => ({ ...prev, isOpen: false }));
      }, 3000);
      
      return () => clearTimeout(timer);
    }
  }, [alert.isOpen]);
  
  // Cleanup blob URLs when component unmounts
  useEffect(() => {
    return () => {
      if (audioFile && audioFile.startsWith && audioFile.startsWith('blob:')) {
        URL.revokeObjectURL(audioFile);
      }
    };
  }, [audioFile]);
  
  return (
    <div className="container">
      <h1>WaveSurfer with Regions and VLC</h1>
      
      <StatusBar status={status.text} type={status.type} />
      
      <UploadPanel onFileUpload={handleFileUpload} />
      
      <WaveSurferComponent
        audioFile={audioFile}
        isPlaying={isPlaying}
        loopRegions={loopRegions}
        zoomLevel={zoomLevel}
        playbackSpeed={playbackSpeed}
        isMuted={waveSurferMuted}
        onPlayPause={handlePlayPause}
        onReady={handleReady}
        onRegionActivated={handleRegionActivated}
      />
      
      <div className="all-controls">
        {/* First row: sliders for zoom and speed */}
        <div className="controls-row">
          {/* Zoom control slider */}
          <div className="slider-container">
            <span className="slider-label">Zoom:</span>
            <input
              type="range"
              id="zoom-slider"
              min="10"
              max="1000"
              value={zoomLevel}
              onChange={(e) => setZoomLevel(Number(e.target.value))}
            />
            <span id="zoom-value" className="slider-value">{zoomLevel}</span>
          </div>

          {/* Playback speed control slider */}
          <div className="slider-container">
            <span className="slider-label">Speed:</span>
            <input
              type="range"
              id="speed-slider"
              min="0.5"
              max="3"
              step="0.1"
              value={playbackSpeed}
              onChange={(e) => setPlaybackSpeed(Number(e.target.value))}
            />
            <span id="speed-value" className="slider-value">{playbackSpeed.toFixed(1)}x</span>
          </div>
        </div>
        
        {/* Second row: combined WaveSurfer and VLC controls */}
        <div className="main-controls">
          {/* WaveSurfer control buttons */}
          <div className="player-buttons">
            <button id="play-pause" onClick={() => handlePlayPause()}>
              {isPlaying ? 'Pause' : 'Play'}
            </button>
            <button 
              id="toggle-mute" 
              onClick={handleToggleWaveSurferMute} 
              disabled={!isReady}
              className={waveSurferMuted ? 'muted' : ''}
              title={waveSurferMuted ? 'Unmute WaveSurfer audio' : 'Mute WaveSurfer audio (VLC audio stays active)'}
            >
              <i className={`fas ${waveSurferMuted ? 'fa-volume-mute' : 'fa-volume-up'}`}></i> WS
            </button>
            <button id="zoom-in" onClick={handleZoomIn} disabled={!isReady}>
              Zoom In
            </button>
            <button id="zoom-out" onClick={handleZoomOut} disabled={!isReady}>
              Zoom Out
            </button>
            <button id="reset-zoom" onClick={handleResetZoom} disabled={!isReady}>
              Reset Zoom
            </button>
            <button id="clear-regions" className="danger" onClick={handleClearRegions} disabled={!isReady}>
              Clear Regions
            </button>
          </div>
          
          {/* VLC controls section */}
          <div className="vlc-section">
            <VLCController
              mediaFile={originalFile}
              wavesurferInstance={wavesurferRef.current}
              activeRegion={activeRegion}
              onStatusChange={handleVLCStatusChange}
              onError={handleVLCError}
              onRegionPlayback={handleVLCRegionPlayback}
            />
          </div>
        </div>
      </div>
      
      {alert.isOpen && (
        <div className={`alert alert-${alert.type}`}>
          {alert.message}
        </div>
      )}
    </div>
  );
}

export default App;

================================================================================
File: src/assets/styles/integrated-controls.css
================================================================================

/**
 * File: src/assets/styles/integrated-controls.css
 * Description: CSS for the integrated controls row
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation
 */

.all-controls {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 1000px;
  margin: 20px auto;
}
/* Mute button specific styling */
.player-buttons button#toggle-mute {
  background-color: #28a745; /* Green when unmuted */
  position: relative;
}

.player-buttons button#toggle-mute:hover {
  background-color: #218838;
}

.player-buttons button#toggle-mute.muted {
  background-color: #dc3545; /* Red when muted */
  animation: pulse 2s infinite;
}

.player-buttons button#toggle-mute.muted:hover {
  background-color: #c82333;
}

/* Pulse animation for muted state */
@keyframes pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(220, 53, 69, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(220, 53, 69, 0);
  }
}

/* Tooltip enhancement for mute button */
.player-buttons button#toggle-mute::after {
  content: attr(title);
  position: absolute;
  bottom: 150%;
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: white;
  padding: 5px 8px;
  border-radius: 4px;
  font-size: 0.75rem;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s;
  z-index: 1000;
}

.player-buttons button#toggle-mute:hover::after {
  opacity: 1;
}
/* Combined controls row with all controls in one line */
.controls-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 15px;
  background-color: #1d1919;
  border-radius: 25px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  margin-bottom: 15px;
}

.slider-container {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 200px;
  margin: 0 10px;
}

.slider-label {
  margin-right: 5px;
  min-width: 45px;
  white-space: nowrap;
  color: #adb5bd;
}

.slider-value {
  min-width: 35px;
  text-align: right;
  color: #0dcaf0;
}

input[type='range'] {
  flex-grow: 1;
  margin: 0 5px;
  height: 8px;
  border-radius: 4px;
  background: #555555;
  outline: none;
}

input[type='range']::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

input[type='range']::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

/* Main controls container */
.main-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  width: 100%;
  background-color: #1d1919;
  border-radius: 25px;
  padding: 15px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* Player buttons */
.player-buttons {
  display: flex;
  flex-wrap: wrap;
  margin-right: 20px;
}

.player-buttons button {
  background-color: #4363ca;
  color: #ffffff;
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  margin: 0 5px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.player-buttons button:hover {
  background-color: #357ea8;
}

.player-buttons button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.player-buttons button.danger {
  background-color: #dc3545;
}

.player-buttons button.danger:hover {
  background-color: #c82333;
}

/* VLC controls */
.vlc-section {
  display: flex;
  align-items: center;
  flex: 1;
  margin-left: 20px;
  border-left: 1px solid #333;
  padding-left: 20px;
}

/* VLC button styles */
.vlc-controls button {
  background-color: transparent;
  color: #f8f9fa;
  border: none;
  padding: 8px 12px;
  margin: 0 5px;
  border-radius: 5px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.vlc-controls button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: #0dcaf0;
}

.vlc-controls button i {
  font-size: 1.2rem;
}

.vlc-launch {
  background-color: #dc3545 !important;
  color: #ffffff !important;
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  margin-right: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.vlc-launch:hover {
  background-color: #c82333 !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.vlc-launch:disabled {
  background-color: #6c757d !important;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.vlc-status {
  margin-left: auto;
  display: flex;
  align-items: center;
}

.status-label {
  color: #6c757d;
  margin-right: 8px;
}

.status-value {
  font-weight: bold;
}

.status-value.playing {
  color: #28a745;
}

.status-value.paused {
  color: #ffc107;
}

/* Alert message */
.alert {
  padding: 12px 16px;
  margin-top: 15px;
  border-radius: 8px;
  text-align: center;
  animation: fadeIn 0.3s ease-in;
}

.alert-info {
  background-color: rgba(13, 202, 240, 0.15);
  color: #0dcaf0;
}

.alert-success {
  background-color: rgba(40, 167, 69, 0.15);
  color: #28a745;
}

.alert-warning {
  background-color: rgba(255, 193, 7, 0.15);
  color: #ffc107;
}

.alert-danger {
  background-color: rgba(220, 53, 69, 0.15);
  color: #dc3545;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .main-controls {
    flex-direction: column;
  }

  .player-buttons,
  .vlc-section {
    width: 100%;
    margin: 10px 0;
    padding: 0;
    border-left: none;
  }

  .vlc-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #333;
  }

  .slider-container {
    flex-direction: column;
    align-items: flex-start;
  }

  .slider-label {
    margin-bottom: 5px;
  }

  .controls-row {
    flex-direction: column;
  }

  .vlc-controls {
    flex-wrap: wrap;
    justify-content: center;
  }
}


================================================================================
File: src/assets/styles/main.css
================================================================================

/**
 * File: src/assets/styles/main.css
 * Description: Main application styling
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation based on original HTML
 * v1.0.1 (2025-05-19) - Fixed corrupted CSS rule for waveform container
 * v1.0.2 (2025-05-19) - Updated container widths to 95% and fixed background colors
 */

body {
  background-color: #212529;
  color: #f8f9fa;
  font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 1200px; /* Slightly wider container */
  margin: 0 auto;
}

h1 {
  text-align: center;
  margin-bottom: 30px;
}

/* Card styling */
.card {
  background-color: #1a1a1a;
  border-radius: 5px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
  margin-bottom: 20px;
}

.card-body {
  padding: 20px;
}

/* Single container for waveform, spectrogram and timeline */
#waveform-container {
  width: 95% !important; /* Force 95% width */
  margin: 0 auto 20px auto !important; /* Center the container */
  background-color: #1a1a1a;
  border-radius: 5px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
  position: relative;
  /* Default height will include both waveform, spectrogram and timeline */
  height: 560px;
  /* Makes sure content is visible */
  overflow: visible !important;
}

/* Only keep minimap separate */
#minimap {
  width: 95% !important; /* Force 95% width */
  height: 40px;
  margin: 0 auto 20px auto !important; /* Center the minimap */
  background-color: #1a1a1a;
  border-radius: 5px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

/* Controls row */
.controls-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  width: 95%; /* Match waveform width */
  max-width: 1200px;
  margin: 20px auto;
  padding: 15px;
  background-color: #1d1919;
  border-radius: 25px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.slider-container {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 250px;
  margin: 0 10px;
}

.slider-label {
  margin-right: 5px;
  min-width: 45px;
  white-space: nowrap;
  color: #adb5bd;
}

.slider-value {
  min-width: 35px;
  text-align: right;
  color: #0dcaf0;
}

input[type='range'] {
  flex-grow: 1;
  margin: 0 5px;
  height: 8px;
  border-radius: 4px;
  background: #555555;
  outline: none;
}

input[type='range']::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

input[type='range']::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

.checkbox-container {
  display: flex;
  align-items: center;
  margin: 0 10px;
  min-width: 120px;
}

/* Player control buttons */
.controls {
  display: flex;
  justify-content: center;
  margin: 20px 0;
  flex-wrap: wrap;
  width: 95%; /* Match waveform width */
  margin: 20px auto;
}

button {
  background-color: #4363ca;
  color: #ffffff;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  margin: 5px 10px;
  cursor: pointer;
}

button:hover {
  background-color: #357ea8;
}

button.danger {
  background-color: #dc3545;
}

button.danger:hover {
  background-color: #c82333;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Loading container */
.loading-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-color: rgba(26, 26, 26, 0.8);
  z-index: 10;
  border-radius: 5px;
}

.simple-spinner {
  width: 40px;
  height: 40px;
  margin-bottom: 20px;
  border: 4px solid rgba(13, 202, 240, 0.2);
  border-top: 4px solid #0dcaf0;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  color: #f8f9fa;
  font-size: 1.2rem;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Status styling */
.status {
  text-align: center;
  padding: 10px;
  margin: 10px 0;
  background-color: #222;
  border-radius: 5px;
  width: 95%; /* Match waveform width */
  margin: 10px auto;
}

.text-info {
  color: #0dcaf0 !important;
}

.text-success {
  color: #28a745 !important;
}

.text-warning {
  color: #ffc107 !important;
}

.text-danger {
  color: #dc3545 !important;
}

.fw-bold {
  font-weight: bold !important;
}

/* Alert message styling */
.alert {
  padding: 12px 16px;
  margin-top: 15px;
  border-radius: 8px;
  text-align: center;
  animation: fadeIn 0.3s ease-in;
  width: 95%; /* Match waveform width */
  margin: 15px auto;
}

.alert-info {
  background-color: rgba(13, 202, 240, 0.15);
  color: #0dcaf0;
}

.alert-success {
  background-color: rgba(40, 167, 69, 0.15);
  color: #28a745;
}

.alert-warning {
  background-color: rgba(255, 193, 7, 0.15);
  color: #ffc107;
}

.alert-danger {
  background-color: rgba(220, 53, 69, 0.15);
  color: #dc3545;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Utility classes */
.mb-4 {
  margin-bottom: 1.5rem !important;
}

.m-0 {
  margin: 0 !important;
}

.me-2 {
  margin-right: 0.5rem !important;
}

/* Current time display */
.current-time {
  text-align: center;
  margin-bottom: 10px;
  width: 95%; /* Match waveform width */
  margin: 0 auto 10px auto;
  color: #0dcaf0;
  font-weight: bold;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  #waveform-container {
    height: 400px;
  }

  .slider-container {
    flex-direction: column;
    align-items: flex-start;
  }

  .slider-label {
    margin-bottom: 5px;
  }

  .controls-row {
    flex-direction: column;
  }

  .checkbox-container {
    margin: 10px 0;
  }
}


================================================================================
File: src/assets/styles/upload-panel.css
================================================================================

/**
File: src/assets/styles/upload-panel.css
Description: Styling for the upload panel
Version History:
v1.0.0 (2025-05-18) - Initial implementation */
/* Upload toggle styling */

.upload-toggle {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  cursor: pointer;
  border-bottom: 1px solid #333;
  transition: background-color 0.2s ease;
}

.upload-toggle:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

.upload-toggle-icon {
  transition: transform 0.3s;
}

.upload-toggle-icon.open {
  transform: rotate(180deg);
}

/* Upload area enhanced hover styling */
.upload-area {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
  border: 2px dashed #6c757d;
  border-radius: 10px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  margin: 0 auto;
  max-width: 65%;
}

.upload-area:hover {
  transform: scale(1.03) !important;
  box-shadow: 0 8px 20px rgba(13, 202, 240, 0.2) !important;
  border-color: #0dcaf0 !important;
  background-color: rgba(13, 202, 240, 0.1) !important;
}

.upload-area.drag-active {
  border-color: #0dcaf0;
  background-color: rgba(13, 202, 240, 0.1);
  transform: scale(1.03);
}

#upload-icon {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
}

.upload-area:hover #upload-icon {
  transform: translateY(-8px) scale(1.1) !important;
  color: #0dcaf0 !important;
  filter: drop-shadow(0 5px 10px rgba(13, 202, 240, 0.3));
}

#upload-text {
  transition: all 0.4s ease !important;
}

.upload-area:hover #upload-text {
  transform: scale(1.05);
  color: #0dcaf0 !important;
  font-weight: bold !important;
}

/* Hidden file input */
.hidden-input {
  display: none;
}

/* File info display */
#file-info-display {
  text-align: center;
  padding: 10px 0;
}

/* Launch button enhanced hover */
.launch-btn {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
}

.launch-btn:hover {
  transform: translateY(-3px) scale(1.03) !important;
  box-shadow: 0 8px 20px rgba(13, 202, 240, 0.4) !important;
  background-color: #0dcaf0 !important;
  letter-spacing: 0.5px;
}

.launch-btn:active {
  transform: translateY(1px) !important;
  box-shadow: 0 3px 10px rgba(13, 202, 240, 0.3) !important;
}

/* Utility classes */
.text-info-emphasis {
  color: #6c757d;
}

.fw-bold {
  font-weight: bold;
}

.small {
  font-size: 0.875rem;
}

.mt-1 {
  margin-top: 0.25rem;
}

.mt-2 {
  margin-top: 0.5rem;
}

.mt-4 {
  margin-top: 1.5rem;
}

.mb-3 {
  margin-bottom: 1rem;
}

.text-center {
  text-align: center;
}

.text-muted {
  color: #6c757d;
}

.text-light {
  color: #f8f9fa;
}

.text-success {
  color: #28a745;
}

/* Font Awesome icon overrides */
.fas {
  font-family: 'Font Awesome 5 Free';
}

.fa-3x {
  font-size: 3em;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .upload-area {
    max-width: 100%;
    padding: 20px 10px;
  }
}


================================================================================
File: src/assets/styles/vlc-controller.css
================================================================================

/**
 * File: src/assets/styles/vlc-controller.css
 * Description: Styles for VLC controller
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation
 */

.vlc-controls {
  display: flex;
  align-items: center;
  margin-top: 1rem;
  background-color: #1d1919;
  border-radius: 25px;
  padding: 12px 20px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.vlc-launch {
  background-color: #dc3545;
  color: #ffffff;
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  margin-right: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.vlc-launch:hover {
  background-color: #c82333;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.vlc-launch:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.vlc-launch i {
  margin-right: 5px;
}

.vlc-playback-controls {
  display: flex;
  align-items: center;
  flex: 1;
}

.vlc-playback-controls.disabled {
  opacity: 0.6;
  pointer-events: none;
}

.vlc-playback-controls button {
  background-color: transparent;
  color: #f8f9fa;
  border: none;
  padding: 8px 12px;
  margin: 0 5px;
  border-radius: 5px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.vlc-playback-controls button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: #0dcaf0;
}

.vlc-playback-controls button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.vlc-playback-controls button i {
  font-size: 1.2rem;
}

.vlc-status {
  margin-left: auto;
  display: flex;
  align-items: center;
}

.status-label {
  color: #6c757d;
  margin-right: 8px;
}

.status-value {
  font-weight: bold;
}

.status-value.not {
  color: #6c757d;
}

.status-value.ready {
  color: #0dcaf0;
}

.status-value.playing {
  color: #28a745;
}

.status-value.paused,
.status-value.stopped {
  color: #ffc107;
}

.status-value.error {
  color: #dc3545;
}

.vlc-alert {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  border-radius: 5px;
  animation: slideIn 0.3s ease-out;
  z-index: 1000;
  max-width: 300px;
}

.alert-info {
  background-color: rgba(13, 202, 240, 0.2);
  border-left: 4px solid #0dcaf0;
  color: #0dcaf0;
}

.alert-success {
  background-color: rgba(40, 167, 69, 0.2);
  border-left: 4px solid #28a745;
  color: #28a745;
}

.alert-warning {
  background-color: rgba(255, 193, 7, 0.2);
  border-left: 4px solid #ffc107;
  color: #ffc107;
}

.alert-danger {
  background-color: rgba(220, 53, 69, 0.2);
  border-left: 4px solid #dc3545;
  color: #dc3545;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Make the VLC controls responsive */
@media (max-width: 768px) {
  .vlc-controls {
    flex-direction: column;
    padding: 15px;
  }

  .vlc-launch {
    margin-bottom: 15px;
    margin-right: 0;
    width: 100%;
  }

  .vlc-playback-controls {
    flex-wrap: wrap;
    justify-content: center;
  }

  .vlc-status {
    margin: 15px auto 0;
  }
}


================================================================================
File: src/components/StatusBar.js
================================================================================

/**
 * File: src/components/StatusBar.js
 * Description: Status indicator component
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 */

import React from 'react';

const StatusBar = ({ status, type }) => {
  return (
    <div className="status">
      <span className={`text-${type} fw-bold`}>
        Status: {status}
      </span>
    </div>
  );
};

export default StatusBar;

================================================================================
File: src/components/UploadPanel.js
================================================================================

/**
 * File: src/components/UploadPanel.js
 * Description: File upload panel component
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 * v1.0.1 (2025-05-21) - Removed redundant Load Audio button - Maoz Lahav
 */

import React, { useState, useRef } from 'react';
import '../assets/styles/upload-panel.css';

const UploadPanel = ({ onFileUpload }) => {
  const [isDragging, setIsDragging] = useState(false);
  const [uploadedFile, setUploadedFile] = useState(null);
  const [isCollapsed, setIsCollapsed] = useState(false);
  const fileInputRef = useRef(null);
  
  // Handle file selection
  const handleFileChange = (event) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      const file = files[0];
      handleFile(file);
    }
  };
  
  // Handle file drop
  const handleDrop = (event) => {
    event.preventDefault();
    setIsDragging(false);
    
    if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
      const file = event.dataTransfer.files[0];
      handleFile(file);
    }
  };
  
  // Process the uploaded file
  const handleFile = (file) => {
    // Check if file is audio or video
    const acceptedTypes = [
      'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/flac', 'audio/aac', 
      'video/mp4', 'video/webm', 'video/ogg', 'video/avi', 'video/mkv', 'video/mov'
    ];
    
    if (!acceptedTypes.includes(file.type)) {
      alert('Please upload an audio or video file.');
      return;
    }
    
    setUploadedFile(file);
    onFileUpload(file);
  };
  
  // Drag events
  const handleDragOver = (event) => {
    event.preventDefault();
    setIsDragging(true);
  };
  
  const handleDragLeave = () => {
    setIsDragging(false);
  };
  
  // Format file size
  const formatFileSize = (size) => {
    // Define size units
    const units = ["B", "KB", "MB", "GB", "TB"];
    
    // Calculate the appropriate unit
    let i = 0;
    let sizeBytes = size;
    while (sizeBytes >= 1024 && i < units.length - 1) {
      sizeBytes /= 1024;
      i++;
    }
    
    // Format the result with 2 decimal places if needed
    if (i > 0) {
      return `${sizeBytes.toFixed(2)} ${units[i]}`;
    } else {
      return `${sizeBytes} ${units[i]}`;
    }
  };
  
  // Get file type display
  const getFileTypeDisplay = (file) => {
    if (file.type.startsWith('audio/')) return 'audio';
    if (file.type.startsWith('video/')) return 'video';
    return 'file';
  };
  
  return (
    <div className="card mb-4">
      {/* Collapse toggle */}
      <div className="upload-toggle" onClick={() => setIsCollapsed(!isCollapsed)}>
        <h3 className="m-0">
          <i className="fas fa-file-upload me-2 text-info"></i>
          Upload Audio/Video
        </h3>
        <i className={`fas fa-chevron-down upload-toggle-icon ${isCollapsed ? '' : 'open'}`}></i>
      </div>
      
      {/* Collapsible content */}
      {!isCollapsed && (
        <div className="card-body">
          {/* Upload area */}
          <div 
            className={`upload-area ${isDragging ? 'drag-active' : ''}`}
            onClick={() => fileInputRef.current.click()}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <i id="upload-icon" className="fas fa-file-upload fa-3x mb-3 text-info-emphasis"></i>
            <div id="upload-text" className="fw-bold">Drag and Drop or Click to Upload</div>
            <div className="text-muted small mt-1">Supports audio and video files up to 4GB</div>
            
            {/* Hidden file input */}
            <input
              ref={fileInputRef}
              type="file"
              className="hidden-input"
              accept="audio/*,video/*"
              onChange={handleFileChange}
              id="file-input"
            />
          </div>
          
          {/* Display file info if uploaded */}
          {uploadedFile && (
            <div id="file-info-display" className="text-light font-italic small mt-2">
              <i className="fas fa-check-circle text-success me-2"></i>
              File loaded: {uploadedFile.name} ({formatFileSize(uploadedFile.size)}, {getFileTypeDisplay(uploadedFile)})
              <div className="text-info small mt-1">
                <i className="fas fa-info-circle me-1"></i>
                Waveform and spectrogram are now visible below. You can create regions by dragging on the waveform.
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default UploadPanel;

================================================================================
File: src/components/VLCController.js
================================================================================

/**
 * File: src/components/VLCController.js
 * Description: VLC Media Player controller component
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation based on Dash-VLC controller
 * v1.0.1 (2025-05-19) - Optimized for integration in main controls row
 * v1.0.2 (2025-05-19) - Updated to work with backend API for real VLC control
 * v1.0.3 (2025-05-19) - Fixed file upload and path handling
 * v1.0.4 (2025-05-27) - Improved VLC-WaveSurfer synchronization - Maoz Lahav
 * v1.0.5 (2025-05-27) - Fixed file upload error handling and debugging - Maoz Lahav
 * v1.0.6 (2025-05-27) - Complete rewrite with better error handling and debugging - Maoz Lahav
 * v1.0.7 (2025-06-09) - Enhanced for EXACT mirroring with WaveSurfer - Human Request
 */

import React, { useState, useEffect, useCallback } from 'react';
import '../assets/styles/vlc-controller.css';

const VLCController = ({ 
  mediaFile, 
  onStatusChange,
  wavesurferInstance,
  activeRegion,
  onError,
  onRegionPlayback, 
}) => {
  // State for the VLC controller
  const [isPlaying, setIsPlaying] = useState(false);
  const [status, setStatus] = useState('Not connected');
  const [vlcConnected, setVlcConnected] = useState(false);
  const [serverFilePath, setServerFilePath] = useState(null);
  const [uploadInProgress, setUploadInProgress] = useState(false);
  const [vlcCurrentTime, setVlcCurrentTime] = useState(0);
  const [debugInfo, setDebugInfo] = useState('');
  // v1.0.7 - Added exact mirroring state
  const [exactMirrorActive, setExactMirrorActive] = useState(false);
  const [lastSyncTime, setLastSyncTime] = useState(0);
  const [syncStats, setSyncStats] = useState({ seeks: 0, plays: 0, pauses: 0 });
  
  // Function to update debug info
  const updateDebugInfo = useCallback((message) => {
    // console.log("VLC Debug:", message); // v1.0.7 - Reduced logging to prevent performance issues
    setDebugInfo(message);
  }, []);
  
  // Function to upload file to server
  const uploadFileToServer = useCallback(async (file) => {
    if (!file) {
      updateDebugInfo("No file provided for upload");
      return null;
    }
    
    try {
      setUploadInProgress(true);
      updateDebugInfo(`Starting upload: ${file.name} (${file.size} bytes, ${file.type})`);
      
      const formData = new FormData();
      formData.append('file', file);
      
      updateDebugInfo("Sending file to server...");
      
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });
      
      updateDebugInfo(`Upload response: ${response.status} ${response.statusText}`);
      
      if (!response.ok) {
        const errorText = await response.text();
        updateDebugInfo(`Upload failed: ${response.status} - ${errorText}`);
        throw new Error(`Upload failed: ${response.status} - ${errorText}`);
      }
      
      const result = await response.json();
      updateDebugInfo(`Upload result: ${JSON.stringify(result)}`);
      
      setUploadInProgress(false);
      
      if (result.success) {
        updateDebugInfo(`File uploaded successfully to: ${result.filePath}`);
        return result.filePath;
      } else {
        throw new Error(result.message || 'Upload failed');
      }
    } catch (error) {
      setUploadInProgress(false);
      updateDebugInfo(`Upload error: ${error.message}`);
      if (onError) onError(`Error uploading file: ${error.message}`);
      return null;
    }
  }, [onError, updateDebugInfo]);
  
  // Effect to upload file to server when mediaFile changes
  useEffect(() => {
    updateDebugInfo(`MediaFile changed: ${mediaFile ? (mediaFile.name || 'URL') : 'null'}`);
    
    const uploadFile = async () => {
      if (mediaFile && mediaFile instanceof File) {
        updateDebugInfo(`Processing File object: ${mediaFile.name}`);
        
        // Create a file identifier to check if we've already uploaded this exact file
        const fileName = mediaFile.name;
        const fileSize = mediaFile.size;
        const fileLastModified = mediaFile.lastModified;
        const fileIdentifier = `${fileName}-${fileSize}-${fileLastModified}`;
        
        // Check cache
        const lastUploadedFile = localStorage.getItem('lastUploadedFile');
        const lastFilePath = localStorage.getItem('lastFilePath');
        
        if (lastUploadedFile === fileIdentifier && lastFilePath) {
          updateDebugInfo(`Using cached file path: ${lastFilePath}`);
          setServerFilePath(lastFilePath);
        } else {
          updateDebugInfo("Uploading new file...");
          const filePath = await uploadFileToServer(mediaFile);
          if (filePath) {
            setServerFilePath(filePath);
            localStorage.setItem('lastUploadedFile', fileIdentifier);
            localStorage.setItem('lastFilePath', filePath);
            updateDebugInfo(`File path saved: ${filePath}`);
          } else {
            updateDebugInfo("Failed to upload file");
            setServerFilePath(null);
          }
        }
      } else if (mediaFile && typeof mediaFile === 'string') {
        updateDebugInfo(`Processing URL string: ${mediaFile}`);
        setServerFilePath(mediaFile);
      } else {
        updateDebugInfo("No media file provided");
        setServerFilePath(null);
      }
    };
    
    uploadFile();
  }, [mediaFile, uploadFileToServer, updateDebugInfo]);
  
  // v1.0.9 - WORKING VLC command system with REAL sync
  const sendVLCCommand = useCallback(async (command, source = 'manual') => {
    try {
      if (!vlcConnected) {
        console.error(`Cannot send command "${command}" - VLC not connected`);
        return null;
      }
      
      console.log(`ðŸŽ® [${source}] SENDING VLC COMMAND: ${command}`);
      
      const response = await fetch('/api/vlc-command', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ command })
      });
      
      if (!response.ok) {
        throw new Error(`VLC command failed: ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log(`âœ… [${source}] VLC COMMAND SUCCESS: ${command}`);
      
      // Update local state based on command
      if (command === 'pause') {
        const newState = !isPlaying;
        setIsPlaying(newState);
        setStatus(newState ? 'Playing' : 'Paused');
        console.log(`ðŸ”„ VLC state updated: ${newState ? 'PLAYING' : 'PAUSED'}`);
      }
      
      return result.response;
    } catch (error) {
      console.error(`âŒ [${source}] VLC COMMAND FAILED: ${command} - ${error.message}`);
      if (onError) onError(`VLC Error: ${error.message}`);
      return null;
    }
  }, [vlcConnected, onError, isPlaying]);

  // Function to launch VLC
  const launchVLC = useCallback(async () => {
    updateDebugInfo("Launch VLC button clicked");
    updateDebugInfo(`Server file path: ${serverFilePath}`);
    updateDebugInfo(`Upload in progress: ${uploadInProgress}`);
    
    if (!serverFilePath) {
      const errorMsg = 'No file path available. Please ensure the file is uploaded first.';
      updateDebugInfo(errorMsg);
      if (onError) onError(errorMsg);
      return;
    }

    if (uploadInProgress) {
      const errorMsg = 'File upload is still in progress. Please wait.';
      updateDebugInfo(errorMsg);
      if (onError) onError(errorMsg);
      return;
    }

    try {
      updateDebugInfo(`Attempting to launch VLC with: ${serverFilePath}`);
      
      const requestBody = { mediaPath: serverFilePath };
      updateDebugInfo(`Request body: ${JSON.stringify(requestBody)}`);
      
      const response = await fetch('/api/launch-vlc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });

      updateDebugInfo(`Launch response status: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        const errorText = await response.text();
        updateDebugInfo(`Launch failed: ${response.status} - ${errorText}`);
        throw new Error(`Failed to launch VLC: ${response.statusText} - ${errorText}`);
      }

      const result = await response.json();
      updateDebugInfo(`Launch result: ${JSON.stringify(result)}`);
      
      if (result.success) {
        setVlcConnected(true);
        setStatus('Ready');
        setIsPlaying(false);
        updateDebugInfo("VLC launched successfully");
        
        // v1.0.8 - CRITICAL: Ensure VLC starts PAUSED (backend already does this, but double-check)
        setTimeout(async () => {
          try {
            // Force pause VLC if it's playing to ensure sync
            await sendVLCCommand('pause', 'ensure-paused-on-launch');
            setIsPlaying(false);
            setStatus('Paused (Ready for sync)');
            updateDebugInfo("âœ… VLC confirmed PAUSED and ready for sync");
            
            // v1.0.8 - Activate exact mirroring AFTER ensuring paused state
            setExactMirrorActive(true);
            setSyncStats({ seeks: 0, plays: 0, pauses: 0 });
            
          } catch (error) {
            console.warn("Could not confirm VLC pause state:", error);
          }
        }, 1000); // Wait 1 second for VLC to fully load
        
        // Notify parent component
        if (onStatusChange) {
          onStatusChange({ isPlaying: false });
        }
      } else {
        throw new Error(result.message || 'Unknown error launching VLC');
      }
    } catch (error) {
      updateDebugInfo(`Launch error: ${error.message}`);
      if (onError) onError(`Error launching VLC: ${error.message}`);
      setStatus('Error');
    }
  }, [serverFilePath, uploadInProgress, onStatusChange, onError, updateDebugInfo, sendVLCCommand]);

  // Play/Pause toggle
  const togglePlayPause = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('pause', 'toggle-play-pause');
      const newPlayingState = !isPlaying;
      setStatus(newPlayingState ? 'Playing' : 'Paused');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: newPlayingState });
      }
    } catch (error) {
      updateDebugInfo(`Play/pause error: ${error.message}`);
    }
  }, [vlcConnected, isPlaying, sendVLCCommand, onStatusChange, updateDebugInfo]);

  // Stop playback
  const stopPlayback = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('pause', 'stop-playback');
      await sendVLCCommand('seek 0', 'stop-seek-start');
      setIsPlaying(false);
      setStatus('Stopped');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: false });
      }
    } catch (error) {
      updateDebugInfo(`Stop error: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, onStatusChange, updateDebugInfo]);

  // Seek backward/forward
  const seekMedia = useCallback(async (seconds) => {
    if (!vlcConnected) return;
    
    try {
      const command = `seek ${seconds > 0 ? '+' : ''}${seconds}`;
      await sendVLCCommand(command, 'seek-relative');
    } catch (error) {
      updateDebugInfo(`Seek error: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, updateDebugInfo]);

  // v1.0.9 - WORKING seek function with real VLC commands
  const seekToPosition = useCallback(async (timeInSeconds, source = 'manual') => {
    if (!vlcConnected) {
      console.error("âŒ Cannot seek - VLC not connected");
      return false;
    }
    
    try {
      const preciseTime = Math.max(0, Number(timeInSeconds));
      console.log(`ðŸŽ¯ [${source}] VLC SEEKING TO: ${preciseTime.toFixed(3)} seconds`);
      
      // Use VLC's seek command - format: seek <seconds>
      const seekCommand = `seek ${Math.floor(preciseTime)}`;
      const result = await sendVLCCommand(seekCommand, source);
      
      if (result !== null) {
        setVlcCurrentTime(preciseTime);
        console.log(`âœ… [${source}] VLC SEEK SUCCESS: ${preciseTime.toFixed(3)}s`);
        return true;
      } else {
        console.error("âŒ VLC seek FAILED - no response");
        return false;
      }
    } catch (error) {
      console.error(`âŒ [${source}] VLC SEEK ERROR:`, error);
      return false;
    }
  }, [vlcConnected, sendVLCCommand]);

  // Volume up/down
  const adjustVolume = useCallback(async (amount) => {
    if (!vlcConnected) return;
    
    try {
      const command = amount > 0 ? 'volup 5' : 'voldown 5';
      await sendVLCCommand(command, 'volume-adjust');
    } catch (error) {
      updateDebugInfo(`Volume error: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, updateDebugInfo]);

  // Toggle fullscreen
  const toggleFullscreen = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('fullscreen', 'toggle-fullscreen');
    } catch (error) {
      updateDebugInfo(`Fullscreen error: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, updateDebugInfo]);

  // Test server connection
  const testServerConnection = useCallback(async () => {
    try {
      updateDebugInfo("Testing server connection...");
      const response = await fetch('/ping');
      if (response.ok) {
        const result = await response.json();
        updateDebugInfo(`Server test: ${result.message}`);
      } else {
        updateDebugInfo(`Server test failed: ${response.status}`);
      }
    } catch (error) {
      updateDebugInfo(`Server connection error: ${error.message}`);
    }
  }, [updateDebugInfo]);

  // Run server test on component mount
  useEffect(() => {
    testServerConnection();
  }, [testServerConnection]);

  // Poll for VLC status (every 2 seconds when connected)
  useEffect(() => {
    if (!vlcConnected) return;
    
    const getVlcStatus = async () => {
      try {
        const response = await fetch('/api/vlc-status');
        if (response.ok) {
          const status = await response.json();
          
          // Update local state if different from VLC state
          if (status.isPlaying !== isPlaying) {
            setIsPlaying(status.isPlaying);
            
            // Notify parent component
            if (onStatusChange) {
              onStatusChange({ isPlaying: status.isPlaying });
            }
            
            // Update status text
            setStatus(status.isPlaying ? 'Playing' : 'Paused');
          }
        }
      } catch (error) {
        // Don't spam console with status errors
        // updateDebugInfo(`Status poll error: ${error.message}`);
      }
    };
    
    // Poll for status every 2 seconds
    const statusInterval = setInterval(getVlcStatus, 2000);
    
    return () => {
      clearInterval(statusInterval);
    };
  }, [vlcConnected, isPlaying, onStatusChange]);

  // Effect to handle active region changes
  useEffect(() => {
    if (!vlcConnected || !activeRegion) return;
    
    // Skip click positions that aren't actual regions
    if (activeRegion.isClickPosition) {
      updateDebugInfo(`Ignoring click position: ${activeRegion.start}s`);
      return;
    }
    
    const handleRegionPlayback = async () => {
      try {
        updateDebugInfo(`Playing region: ${activeRegion.id} (${activeRegion.start}s - ${activeRegion.end}s)`);
        
        // v1.0.7 - Exact seek to region start time
        const startTime = activeRegion.start;
        const seekSuccess = await seekToPosition(startTime, 'region-activated');
        
        if (!seekSuccess) {
          updateDebugInfo("Failed to seek to region start time");
          return;
        }
        
        // Resume playback if paused
        if (!isPlaying) {
          await sendVLCCommand('pause', 'region-play'); // VLC uses the same command to toggle
          setIsPlaying(true);
          setStatus('Playing region');
          
          // Notify parent component
          if (onStatusChange) {
            onStatusChange({ isPlaying: true });
          }
        }
        
        // Notify parent component about region playback
        if (onRegionPlayback) {
          onRegionPlayback({
            region: activeRegion,
            vlcTime: startTime,
            isPlaying: true
          });
        }
      } catch (error) {
        updateDebugInfo(`Region playback error: ${error.message}`);
      }
    };
    
    handleRegionPlayback();
  }, [activeRegion, vlcConnected, sendVLCCommand, isPlaying, onStatusChange, seekToPosition, onRegionPlayback, updateDebugInfo]);

  // v1.0.7 - Enhanced VLC control methods for exact mirroring with wavesurfer instance
  useEffect(() => {
    if (vlcConnected && wavesurferInstance && exactMirrorActive) {
      updateDebugInfo("ðŸ”— Attaching EXACT mirroring VLC controls to WaveSurfer");
      
      // v1.0.7 - Enhanced VLC control object with exact timing
      wavesurferInstance.vlc = {
        // Exact seek with microsecond precision
        seekTo: async (timeInSeconds) => {
          const preciseTime = Number(timeInSeconds);
          updateDebugInfo(`ðŸŽ¬ [EXACT] VLC seek requested: ${preciseTime.toFixed(3)}s`);
          return await seekToPosition(preciseTime, 'wavesurfer-exact-seek');
        },
        
        // Immediate play command
        play: async () => {
          updateDebugInfo("â–¶ï¸ [EXACT] VLC play requested");
          if (!isPlaying) {
            await togglePlayPause();
            updateDebugInfo("âœ… [EXACT] VLC started playing");
            return true;
          }
          updateDebugInfo("â„¹ï¸ [EXACT] VLC already playing");
          return false;
        },
        
        // Immediate pause command
        pause: async () => {
          updateDebugInfo("â¸ï¸ [EXACT] VLC pause requested");
          if (isPlaying) {
            await togglePlayPause();
            updateDebugInfo("âœ… [EXACT] VLC paused");
            return true;
          }
          updateDebugInfo("â„¹ï¸ [EXACT] VLC already paused");
          return false;
        },
        
        // Stop with seek to start
        stop: async () => {
          updateDebugInfo("â¹ï¸ [EXACT] VLC stop requested");
          await stopPlayback();
          return true;
        },
        
        // Connection status check
        isConnected: () => vlcConnected && exactMirrorActive,
        
        // Get current VLC time
        getCurrentTime: () => vlcCurrentTime,
        
        // v1.0.7 - Enhanced region playback with exact timing
        playRegion: async (region) => {
          if (!region) return false;
          
          updateDebugInfo(`ðŸŽµ [EXACT] VLC region play: ${region.start.toFixed(3)}s - ${region.end.toFixed(3)}s`);
          
          // First seek to region start with exact timing
          const seekSuccess = await seekToPosition(region.start, 'exact-region-play');
          if (!seekSuccess) {
            updateDebugInfo("âŒ [EXACT] Region seek failed");
            return false;
          }
          
          // Then play if not already playing
          if (!isPlaying) {
            await togglePlayPause();
          }
          
          updateDebugInfo("âœ… [EXACT] Region playback started");
          return true;
        },
        
        // v1.0.7 - Synchronized seek and play method with exact timing
        seekAndPlay: async (timeInSeconds) => {
          const preciseTime = Number(timeInSeconds);
          updateDebugInfo(`ðŸŽ¯ [EXACT] VLC synchronized seek & play: ${preciseTime.toFixed(3)}s`);
          
          // First seek with exact timing
          const seekSuccess = await seekToPosition(preciseTime, 'exact-seek-and-play');
          if (!seekSuccess) {
            updateDebugInfo("âŒ [EXACT] VLC seek failed, cannot play");
            return false;
          }
          
          // Then start playing
          if (!isPlaying) {
            await togglePlayPause();
            updateDebugInfo("âœ… [EXACT] VLC synchronized playback started");
            return true;
          }
          
          updateDebugInfo("â„¹ï¸ [EXACT] VLC was already playing");
          return true;
        },
        
        // v1.0.7 - Get sync statistics
        getSyncStats: () => syncStats,
        
        // v1.0.7 - Reset sync statistics
        resetSyncStats: () => {
          setSyncStats({ seeks: 0, plays: 0, pauses: 0 });
          updateDebugInfo("ðŸ“Š [EXACT] Sync statistics reset");
        },
        
        // v1.0.7 - Force immediate sync check
        forceSyncCheck: async () => {
          updateDebugInfo("ðŸ”„ [EXACT] Force sync check requested");
          // This could trigger a time comparison and correction
          return true;
        },
        
        // v1.0.7 - Advanced seek with frame precision (if needed)
        seekToFrame: async (frameNumber, fps = 25) => {
          const timeInSeconds = frameNumber / fps;
          updateDebugInfo(`ðŸŽ¬ [EXACT] VLC frame seek: frame ${frameNumber} @ ${fps}fps = ${timeInSeconds.toFixed(3)}s`);
          return await seekToPosition(timeInSeconds, 'frame-exact-seek');
        }
      };
      
      updateDebugInfo("ðŸŽ‰ [EXACT] Mirroring VLC controls attached successfully");
      
      // v1.0.7 - Add status indicators to the instance
      wavesurferInstance.vlcStatus = {
        connected: vlcConnected,
        exactMirror: exactMirrorActive,
        syncStats: syncStats,
        lastSyncTime: lastSyncTime,
        currentTime: vlcCurrentTime
      };
      
    } else if (wavesurferInstance) {
      // Remove VLC controls if not connected
      delete wavesurferInstance.vlc;
      delete wavesurferInstance.vlcStatus;
      updateDebugInfo("ðŸ”Œ [EXACT] VLC controls removed (not connected)");
    }
  }, [vlcConnected, wavesurferInstance, seekToPosition, togglePlayPause, isPlaying, stopPlayback, vlcCurrentTime, updateDebugInfo, exactMirrorActive, syncStats, lastSyncTime]);

  // v1.0.7 - Bidirectional sync monitoring for exact mirroring
  useEffect(() => {
    if (!vlcConnected || !exactMirrorActive || !wavesurferInstance) return;
    
    let syncMonitorInterval;
    
    const startBidirectionalSync = () => {
      updateDebugInfo("ðŸ”„ [EXACT] Starting bidirectional sync monitoring");
      
      // Monitor VLC â†’ WaveSurfer sync every 1000ms for smoother playback (reduced from 200ms)
      syncMonitorInterval = setInterval(async () => {
        try {
          // Get current times from both players
          const wsTime = wavesurferInstance.getCurrentTime();
          const vlcTime = vlcCurrentTime;
          
          // Calculate drift
          const timeDrift = Math.abs(wsTime - vlcTime);
          
          // v1.0.7 - Increased tolerance from 200ms to 500ms to reduce stuttering
          // If drift is > 500ms and we're playing, correct it
          if (timeDrift > 0.5 && isPlaying) {
            // updateDebugInfo(`âš ï¸ [EXACT] Time drift detected: ${timeDrift.toFixed(3)}s`); // v1.0.7 - Reduced logging
            
            // Decide which player is the source of truth
            // During region playback, prefer VLC time
            // During normal playback, prefer WaveSurfer time
            if (activeRegion) {
              // Region playback - VLC is master
              const newPosition = vlcTime / wavesurferInstance.getDuration();
              wavesurferInstance.seekTo(newPosition);
              // updateDebugInfo(`ðŸŽ¯ [EXACT] Corrected WaveSurfer to match VLC: ${vlcTime.toFixed(3)}s`); // v1.0.7 - Reduced logging
            } else {
              // Normal playback - WaveSurfer is master
              await seekToPosition(wsTime, 'drift-correction');
              // updateDebugInfo(`ðŸŽ¯ [EXACT] Corrected VLC to match WaveSurfer: ${wsTime.toFixed(3)}s`); // v1.0.7 - Reduced logging
            }
          }
          
        } catch (error) {
          // Silent error handling for sync monitoring
          console.warn("Sync monitoring error:", error);
        }
      }, 1000); // v1.0.7 - Increased interval from 200ms to 1000ms for smoother playback
    };
    
    startBidirectionalSync();
    
    return () => {
      if (syncMonitorInterval) {
        clearInterval(syncMonitorInterval);
        updateDebugInfo("ðŸ›‘ [EXACT] Bidirectional sync monitoring stopped");
      }
    };
  }, [vlcConnected, exactMirrorActive, wavesurferInstance, vlcCurrentTime, isPlaying, activeRegion, seekToPosition, updateDebugInfo]);

  // v1.0.7 - Enhanced keyboard shortcuts for exact VLC control
  useEffect(() => {
    if (!vlcConnected || !exactMirrorActive) return;
    
    const handleVLCKeyboard = (e) => {
      // Only handle if no input is focused
      if (document.activeElement.tagName === 'INPUT') return;
      
      switch (e.code) {
        case 'KeyV':
          if (e.ctrlKey && e.shiftKey) {
            e.preventDefault();
            togglePlayPause();
            updateDebugInfo("âŒ¨ï¸ [EXACT] Ctrl+Shift+V: VLC play/pause");
          }
          break;
          
        case 'KeyS':
          if (e.ctrlKey && e.shiftKey) {
            e.preventDefault();
            stopPlayback();
            updateDebugInfo("âŒ¨ï¸ [EXACT] Ctrl+Shift+S: VLC stop");
          }
          break;
          
        case 'KeyF':
          if (e.ctrlKey && e.shiftKey) {
            e.preventDefault();
            toggleFullscreen();
            updateDebugInfo("âŒ¨ï¸ [EXACT] Ctrl+Shift+F: VLC fullscreen");
          }
          break;
          
        default:
          // v1.0.7 - Added default case to fix ESLint warning
          break;
      }
    };
    
    document.addEventListener('keydown', handleVLCKeyboard);
    
    return () => {
      document.removeEventListener('keydown', handleVLCKeyboard);
    };
  }, [vlcConnected, exactMirrorActive, togglePlayPause, stopPlayback, toggleFullscreen, updateDebugInfo]);

  // Render VLC controller buttons
  return (
    <div className="vlc-controls">
      {/* Launch VLC Button */}
      <button 
        className="vlc-launch"
        onClick={launchVLC}
        disabled={!serverFilePath || vlcConnected || uploadInProgress}
        title={
          uploadInProgress ? "Uploading file..." :
          !serverFilePath ? "Please upload a file first" :
          vlcConnected ? "VLC is already running" :
          "Launch VLC Player"
        }
      >
        <i className="fas fa-external-link-alt"></i> 
        {uploadInProgress ? 'Uploading...' : vlcConnected ? 'Connected' : 'VLC'}
      </button>
      
      {/* Server Test Button (for debugging) */}
      {!vlcConnected && (
        <button
          onClick={testServerConnection}
          title="Test server connection"
          style={{ marginLeft: '5px', fontSize: '0.8rem', padding: '4px 8px' }}
        >
          <i className="fas fa-network-wired"></i> Test
        </button>
      )}
      
      {/* Only show playback controls if VLC is connected */}
      {vlcConnected && (
        <>
          <button
            onClick={togglePlayPause}
            title={isPlaying ? 'Pause' : 'Play'}
          >
            <i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'}`}></i>
          </button>
          
          <button
            onClick={stopPlayback}
            title="Stop"
          >
            <i className="fas fa-stop"></i>
          </button>
          
          <button
            onClick={() => adjustVolume(-5)}
            title="Volume Down"
          >
            <i className="fas fa-volume-down"></i>
          </button>
          
          <button
            onClick={() => adjustVolume(5)}
            title="Volume Up"
          >
            <i className="fas fa-volume-up"></i>
          </button>
          
          <button
            onClick={() => seekMedia(-10)}
            title="Seek Backward 10s"
          >
            <i className="fas fa-backward"></i>
          </button>
          
          <button
            onClick={() => seekMedia(10)}
            title="Seek Forward 10s"
          >
            <i className="fas fa-forward"></i>
          </button>
          
          <button
            onClick={toggleFullscreen}
            title="Toggle Fullscreen"
          >
            <i className="fas fa-expand"></i>
          </button>
        </>
      )}
      
      {/* v1.0.7 - Enhanced status and debug info with exact mirroring indicators */}
      <div className="vlc-status">
        <span className="status-label">VLC:</span>
        <span className={`status-value ${status.toLowerCase().replace(' ', '-')}`}>{status}</span>
        
        {/* v1.0.7 - Exact mirroring status indicator */}
        {exactMirrorActive && (
          <div style={{ fontSize: '0.7rem', color: '#28a745', marginTop: '2px' }}>
            ðŸŽ¯ EXACT MIRROR
          </div>
        )}
        
        {/* v1.0.7 - Sync statistics display */}
        {vlcConnected && exactMirrorActive && (
          <div style={{ fontSize: '0.6rem', color: '#6c757d', marginTop: '2px' }}>
            S:{syncStats.seeks} P:{syncStats.plays} Pa:{syncStats.pauses}
          </div>
        )}
        
        {debugInfo && (
          <div style={{ fontSize: '0.7rem', color: '#888', marginTop: '2px', maxWidth: '200px', wordBreak: 'break-word' }}>
            {debugInfo}
          </div>
        )}
      </div>
    </div>
  );
};

export default VLCController;

================================================================================
File: src/components/WaveSurferComponent.js
================================================================================

/**
 * File: src/components/WaveSurferComponent.js
 * Description: WaveSurfer component using the official @wavesurfer/react hook
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Implementation using @wavesurfer/react
 * v1.0.1 (2025-05-19) - Fixed loading spinner and plugin issues
 * v1.0.2 (2025-05-19) - Fixed infinite update loop and duplicate plugins
 * v1.0.3 (2025-05-19) - Fixed zoom error, region looping and drag selection issues
 * v1.0.4 (2025-05-19) - Fixed region functionality and event handlers
 * v1.0.5 (2025-05-21) - Fixed maximum update depth exceeded warnings - Maoz Lahav
 * v1.0.6 (2025-05-21) - Fixed multiple spectrogram rendering issue - Maoz Lahav
 * v1.0.7 (2025-05-21) - Fixed duplicate spectrograms and minimaps - Maoz Lahav
 * v1.0.8 (2025-05-21) - Complete rewrite to fix duplicates - Maoz Lahav
 * v1.0.9 (2025-05-21) - Fixed hundreds of timelines issue - Maoz Lahav
 * v1.0.10 (2025-05-21) - Implemented official WaveSurfer regions example with random colors - Maoz Lahav
 * v1.0.11 (2025-06-09) - Added EXACT VLC mirroring for all WaveSurfer interactions - Human Request
 * v1.0.12 (2025-06-09) - Fixed syntax errors and duplicate code sections - Human Request
 * v1.0.13 (2025-06-09) - Added EXACT VLC mirroring for all WaveSurfer interactions - Human Request
 * v1.0.14 (2025-06-09) - Fixed VLC auto-start and manual mute control - Human Request  
 * v1.0.15 (2025-06-09) - WORKING VLC sync with real commands and speed control - Human Request
 * v1.0.16 (2025-06-09) - IMPROVED sync timing and region handling - Human Request
 */

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { useWavesurfer } from '@wavesurfer/react';
import '../assets/styles/main.css';

const WaveSurferComponent = ({ 
  audioFile, 
  isPlaying, 
  loopRegions = true,
  dragSelection = true, 
  zoomLevel = 100,
  playbackSpeed = 1.0,
  isMuted = false,
  onPlayPause, 
  onReady,
  onRegionActivated
}) => {
  // Refs
  const containerRef = useRef(null);
  const minimapRef = useRef(null);
  const regionsPluginRef = useRef(null);
  const activeRegionRef = useRef(null);
  const lastZoomLevelRef = useRef(zoomLevel);
  const lastPlaybackSpeedRef = useRef(playbackSpeed);
  const currentAudioFileRef = useRef(null);
  const wavesurferInstanceRef = useRef(null);
  const pluginsRegisteredRef = useRef(false);
  // v1.0.11 - Added VLC sync tracking refs for exact mirroring
  const vlcSyncActiveRef = useRef(false);
  const lastVlcSyncTimeRef = useRef(0);
  const vlcSyncIntervalRef = useRef(null);
  const pendingVlcSeekRef = useRef(null);
  
  // State 
  const [loading, setLoading] = useState(true);
  const [isAudioLoaded, setIsAudioLoaded] = useState(false);
  const [audioUrl, setAudioUrl] = useState(null);
  // v1.0.11 - Added VLC sync status state
  const [vlcSyncStatus, setVlcSyncStatus] = useState('disconnected');
  
  // Random color functions from official example
  const random = useCallback((min, max) => Math.random() * (max - min) + min, []);
  const randomColor = useCallback(() => `rgba(${random(0, 255)}, ${random(0, 255)}, ${random(0, 255)}, 0.5)`, [random]);
  
  // v1.0.16 - FIXED VLC sync utility functions with better error handling
  const vlcSyncUtils = useCallback((wavesurferInstance = null) => {
    const wsInstance = wavesurferInstance || wavesurfer;
    if (!wsInstance || !wsInstance.vlc || !wsInstance.vlc.isConnected()) {
      console.warn("VLC not connected - cannot sync");
      return null;
    }
    
    return {
      // WORKING seek sync with retry
      syncSeekToVLC: async (timeInSeconds, source = 'unknown') => {
        console.log(`ðŸŽ¯ [${source}] SYNC SEEK TO VLC: ${timeInSeconds.toFixed(3)}s`);
        
        try {
          const success = await wsInstance.vlc.seekTo(timeInSeconds);
          if (success) {
            console.log(`âœ… [${source}] VLC SEEK SYNCED: ${timeInSeconds.toFixed(3)}s`);
          } else {
            console.error(`âŒ [${source}] VLC SEEK FAILED`);
          }
          return success;
        } catch (error) {
          console.error(`âŒ [${source}] VLC SEEK ERROR:`, error);
          return false;
        }
      },
      
      // WORKING play/pause sync with state check
      syncPlayStateToVLC: async (shouldPlay, source = 'unknown') => {
        console.log(`ðŸŽµ [${source}] SYNC PLAY STATE TO VLC: ${shouldPlay ? 'PLAY' : 'PAUSE'}`);
        
        try {
          let success = false;
          if (shouldPlay) {
            success = await wsInstance.vlc.play();
          } else {
            success = await wsInstance.vlc.pause();
          }
          
          if (success) {
            console.log(`âœ… [${source}] VLC PLAY STATE SYNCED: ${shouldPlay ? 'PLAYING' : 'PAUSED'}`);
          } else {
            console.error(`âŒ [${source}] VLC PLAY STATE FAILED`);
          }
          return success;
        } catch (error) {
          console.error(`âŒ [${source}] VLC PLAY STATE ERROR:`, error);
          return false;
        }
      },
      
      // WORKING speed sync with immediate application
      syncSpeedToVLC: async (speed, source = 'unknown') => {
        console.log(`âš¡ [${source}] SYNC SPEED TO VLC: ${speed}x`);
        
        try {
          const success = await wsInstance.vlc.setRate(speed);
          if (success) {
            console.log(`âœ… [${source}] VLC SPEED SYNCED: ${speed}x`);
          } else {
            console.error(`âŒ [${source}] VLC SPEED FAILED`);
          }
          return success;
        } catch (error) {
          console.error(`âŒ [${source}] VLC SPEED ERROR:`, error);
          return false;
        }
      },
      
      // IMPROVED region sync with better timing
      syncRegionToVLC: async (region, source = 'unknown') => {
        if (!region) return false;
        
        console.log(`ðŸŽµ [${source}] SYNC REGION TO VLC: ${region.start.toFixed(3)}s - ${region.end.toFixed(3)}s`);
        
        try {
          // First ensure VLC is at the right position
          const seekSuccess = await wsInstance.vlc.seekTo(region.start);
          if (!seekSuccess) {
            console.error(`âŒ [${source}] VLC REGION SEEK FAILED`);
            return false;
          }
          
          // Wait a moment for seek to complete
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // Then start playing
          const playSuccess = await wsInstance.vlc.play();
          if (playSuccess) {
            console.log(`âœ… [${source}] VLC REGION SYNCED AND PLAYING`);
            return true;
          } else {
            console.error(`âŒ [${source}] VLC REGION PLAY FAILED`);
            return false;
          }
        } catch (error) {
          console.error(`âŒ [${source}] VLC REGION ERROR:`, error);
          return false;
        }
      }
    };
  }, []);
  
  // Handle audio file changes
  useEffect(() => {
    const hasFileChanged = currentAudioFileRef.current !== audioFile;
    
    if (hasFileChanged) {
      console.log("Audio file changed:", audioFile ? (audioFile.name || 'URL') : 'null');
      
      // Clean up previous URL
      if (currentAudioFileRef.current && typeof currentAudioFileRef.current === 'string' && currentAudioFileRef.current.startsWith('blob:')) {
        URL.revokeObjectURL(currentAudioFileRef.current);
      }
      
      // Reset all states and flags
      setLoading(true);
      setIsAudioLoaded(false);
      activeRegionRef.current = null;
      wavesurferInstanceRef.current = null;
      pluginsRegisteredRef.current = false;
      // v1.0.11 - Reset VLC sync state on file change
      vlcSyncActiveRef.current = false;
      setVlcSyncStatus('disconnected');
      
      // Create new URL or set to null
      if (audioFile) {
        if (audioFile instanceof File) {
          const newUrl = URL.createObjectURL(audioFile);
          setAudioUrl(newUrl);
          currentAudioFileRef.current = newUrl;
        } else {
          setAudioUrl(audioFile);
          currentAudioFileRef.current = audioFile;
        }
      } else {
        setAudioUrl(null);
        currentAudioFileRef.current = null;
      }
    }
    
    // Cleanup on unmount
    return () => {
      if (currentAudioFileRef.current && typeof currentAudioFileRef.current === 'string' && currentAudioFileRef.current.startsWith('blob:')) {
        URL.revokeObjectURL(currentAudioFileRef.current);
      }
    };
  }, [audioFile]);
  
  // Initialize WaveSurfer
  const { wavesurfer, currentTime, isReady } = useWavesurfer({
    container: containerRef,
    height: 180,
    waveColor: '#b8b8b8',
    progressColor: '#08c3f2',
    cursorColor: '#ff5722',
    cursorWidth: 2,
    minPxPerSec: 100,
    url: audioUrl,
    normalize: true,
    autoScroll: true,
    autoCenter: true,
  });
  
  // v1.0.16 - IMPROVED region event handlers with better VLC sync
  const handleRegionIn = useCallback((region) => {
    console.log(`ðŸŽµ Region IN: ${region.start.toFixed(3)}s`);
    activeRegionRef.current = region;
    
    // Sync region entry to VLC immediately
    const syncUtils = vlcSyncUtils(wavesurfer);
    if (syncUtils) {
      syncUtils.syncSeekToVLC(region.start, 'region-in');
    }
  }, [wavesurfer, vlcSyncUtils]);
  
  const handleRegionOut = useCallback((region) => {
    console.log(`ðŸŽµ Region OUT: ${region.end.toFixed(3)}s`);
    if (activeRegionRef.current === region) {
      if (loopRegions) {
        console.log("ðŸ”„ Looping region");
        region.play();
        // Sync region loop to VLC
        const syncUtils = vlcSyncUtils(wavesurfer);
        if (syncUtils) {
          syncUtils.syncRegionToVLC(region, 'region-loop');
        }
      } else {
        activeRegionRef.current = null;
      }
    }
  }, [loopRegions, wavesurfer, vlcSyncUtils]);
  
  const handleRegionClick = useCallback((region, e) => {
    console.log(`ðŸŽµ Region CLICKED: ${region.start.toFixed(3)}s - ${region.end.toFixed(3)}s`);
    e.stopPropagation(); // prevent triggering a click on the waveform
    activeRegionRef.current = region;
    
    // Give it a new random color
    region.setOptions({ color: randomColor() });
    
    // IMMEDIATE VLC sync for region click
    const syncUtils = vlcSyncUtils(wavesurfer);
    if (syncUtils) {
      console.log("ðŸŽ¯ Syncing clicked region to VLC");
      syncUtils.syncRegionToVLC(region, 'region-click');
    }
    
    // Play the region in WaveSurfer
    region.play(true); // restart the region
    
    // Update parent component play state
    if (onPlayPause) {
      onPlayPause(true);
    }
    
    // Notify parent component about the active region
    if (onRegionActivated) {
      onRegionActivated(region);
    }
  }, [onPlayPause, onRegionActivated, randomColor, wavesurfer, vlcSyncUtils]);
  
  const handleRegionUpdated = useCallback((region) => {
    // Auto-select the newly updated region
    activeRegionRef.current = region;
    
    // Give it a random color like the official example
    region.setOptions({ color: randomColor() });
    
    // v1.0.11 - Sync region boundary changes to VLC
    const syncUtils = vlcSyncUtils(wavesurfer);
    if (syncUtils) {
      // When region is resized/moved, seek VLC to new start position
      syncUtils.syncSeekToVLC(region.start, 'region-updated');
    }
    
    // Notify parent component about the active region
    if (onRegionActivated) {
      onRegionActivated(region);
    }
  }, [onRegionActivated, randomColor, wavesurfer, vlcSyncUtils]);
  
  const handleWaveformClick = useCallback((event) => {
    // Reset active region color if any
    if (activeRegionRef.current) {
      try {
        activeRegionRef.current.setOptions({ color: 'rgba(0,0,255,0.4)' });
      } catch (error) {
        console.error("Error resetting active region color:", error);
      }
      activeRegionRef.current = null;
    }
    
    // v1.0.11 - Enhanced VLC synchronization for direct clicks with exact positioning
    if (wavesurfer && event && typeof event.relativeX === 'number') {
      try {
        const duration = wavesurfer.getDuration();
        if (duration && duration > 0) {
          const clickTime = event.relativeX * duration;
          
          // v1.0.11 - Immediate exact VLC sync for waveform clicks
          const syncUtils = vlcSyncUtils(wavesurfer);
          if (syncUtils) {
            syncUtils.syncSeekToVLC(clickTime, 'waveform-click');
            
            // v1.0.11 - If WaveSurfer is playing, ensure VLC continues playing
            if (wavesurfer.isPlaying()) {
              syncUtils.syncPlayStateToVLC(true, 'waveform-click-play');
            }
          }
        }
        
      } catch (error) {
        console.error("Error syncing VLC on click:", error);
      }
    }
  }, [wavesurfer, vlcSyncUtils]);
  
  // CRITICAL: One-time plugin registration when wavesurfer instance changes
  useEffect(() => {
    // Only proceed if we have a valid wavesurfer instance and it's ready
    if (!wavesurfer || !isReady) return;
    
    // Check if this is a new wavesurfer instance
    const isNewInstance = wavesurferInstanceRef.current !== wavesurfer;
    
    // Only register plugins for new instances that haven't been processed
    if (isNewInstance && !pluginsRegisteredRef.current) {
      console.log("Registering plugins for new wavesurfer instance...");
      
      // Mark this instance as current
      wavesurferInstanceRef.current = wavesurfer;
      pluginsRegisteredRef.current = true;
      
      // Clear minimap container
      if (minimapRef.current) {
        minimapRef.current.innerHTML = '';
      }
      
      const registerPlugins = async () => {
        try {
          // Import all plugins
          const [
            { default: Timeline },
            { default: Spectrogram },
            { default: Regions },
            { default: Minimap },
            { default: Hover }
          ] = await Promise.all([
            import('wavesurfer.js/dist/plugins/timeline.js'),
            import('wavesurfer.js/dist/plugins/spectrogram.js'),
            import('wavesurfer.js/dist/plugins/regions.js'),
            import('wavesurfer.js/dist/plugins/minimap.js'),
            import('wavesurfer.js/dist/plugins/hover.js')
          ]);
          
          // Double-check we're still working with the same instance
          if (wavesurferInstanceRef.current !== wavesurfer) {
            console.log("Wavesurfer instance changed during plugin import, aborting...");
            return;
          }
          
          console.log("Creating and registering plugins...");
          
          // Create and register each plugin
          const regionsPlugin = Regions.create();
          wavesurfer.registerPlugin(regionsPlugin);
          regionsPluginRef.current = regionsPlugin;
          
          const timelinePlugin = Timeline.create({
            height: 30,
            timeInterval: 1,
            primaryColor: '#ffffff',
            secondaryColor: '#aaaaaa',
            primaryFontColor: '#ffffff',
            secondaryFontColor: '#dddddd',
          });
          wavesurfer.registerPlugin(timelinePlugin);
          
          const spectrogramPlugin = Spectrogram.create({
            labels: true,
            height: 350,
            splitChannels: false,
            colorMap: 'roseus',
            frequencyMax: 8000,
            frequencyMin: 0,
            fftSamples: 512,
            noverlap: 0,
          });
          wavesurfer.registerPlugin(spectrogramPlugin);
          
          const hoverPlugin = Hover.create({
            lineColor: '#ff5722',
            lineWidth: 2,
            labelBackground: '#111111',
            labelColor: '#ffffff',
          });
          wavesurfer.registerPlugin(hoverPlugin);
          
          const minimapPlugin = Minimap.create({
            container: minimapRef.current,
            height: 40,
            waveColor: '#b8b8b8',
            progressColor: '#08c3f2',
          });
          wavesurfer.registerPlugin(minimapPlugin);
          
          // Enable drag selection - exactly like the official example
          regionsPlugin.enableDragSelection({
            color: 'rgba(255, 0, 0, 0.1)',
          });
          
          // Set up event listeners - following the official example pattern exactly
          regionsPlugin.on('region-in', handleRegionIn);
          regionsPlugin.on('region-out', handleRegionOut);
          regionsPlugin.on('region-clicked', handleRegionClick);
          regionsPlugin.on('region-updated', handleRegionUpdated);
          
          // Reset the active region when the user clicks anywhere in the waveform
          wavesurfer.on('interaction', handleWaveformClick);
          
          // v1.0.13 - PERFECT VLC mirroring - every interaction syncs immediately
          wavesurfer.on('seeking', (currentTime) => {
            console.log(`ðŸŽ¯ WaveSurfer SEEKING: ${currentTime.toFixed(3)}s`);
            const syncUtils = vlcSyncUtils(wavesurfer);
            if (syncUtils) {
              syncUtils.syncSeekToVLC(currentTime, 'wavesurfer-seeking');
            }
          });
          
          wavesurfer.on('play', () => {
            console.log("â–¶ï¸ WaveSurfer PLAY event");
            const syncUtils = vlcSyncUtils(wavesurfer);
            if (syncUtils) {
              syncUtils.syncPlayStateToVLC(true, 'wavesurfer-play');
            }
          });
          
          wavesurfer.on('pause', () => {
            console.log("â¸ï¸ WaveSurfer PAUSE event");
            const syncUtils = vlcSyncUtils(wavesurfer);
            if (syncUtils) {
              syncUtils.syncPlayStateToVLC(false, 'wavesurfer-pause');
            }
          });
          
          // v1.0.13 - Plugin click events sync immediately
          timelinePlugin.on && timelinePlugin.on('click', (time) => {
            console.log(`ðŸ• Timeline clicked: ${time.toFixed(3)}s`);
            const syncUtils = vlcSyncUtils(wavesurfer);
            if (syncUtils) {
              syncUtils.syncSeekToVLC(time, 'timeline-click');
            }
          });
          
          spectrogramPlugin.on && spectrogramPlugin.on('click', (frequency, time) => {
            console.log(`ðŸ“Š Spectrogram clicked: ${time.toFixed(3)}s`);
            const syncUtils = vlcSyncUtils(wavesurfer);
            if (syncUtils) {
              syncUtils.syncSeekToVLC(time, 'spectrogram-click');
            }
          });
          
          minimapPlugin.on && minimapPlugin.on('click', (time) => {
            console.log(`ðŸ—ºï¸ Minimap clicked: ${time.toFixed(3)}s`);
            const syncUtils = vlcSyncUtils(wavesurfer);
            if (syncUtils) {
              syncUtils.syncSeekToVLC(time, 'minimap-click');
            }
          });
          
          // Set up helper methods on wavesurfer instance
          wavesurfer.regions = regionsPlugin;
          wavesurfer.getActiveRegion = () => activeRegionRef.current;
          wavesurfer.clearAllRegions = () => {
            try {
              if (regionsPlugin && typeof regionsPlugin.clearRegions === 'function') {
                regionsPlugin.clearRegions();
                activeRegionRef.current = null; // Reset active region when clearing
                return true;
              }
              return false;
            } catch (error) {
              console.error("Error clearing regions:", error);
              return false;
            }
          };
          
          // Add method to create regions with random colors like the official example
          wavesurfer.createRegion = (options = {}) => {
            try {
              if (regionsPlugin && typeof regionsPlugin.addRegion === 'function') {
                const regionOptions = {
                  color: randomColor(), // Give regions a random color when they are created
                  drag: true,
                  resize: true,
                  ...options
                };
                
                const region = regionsPlugin.addRegion(regionOptions);
                
                // v1.0.11 - Immediately sync new region to VLC
                const syncUtils = vlcSyncUtils(wavesurfer);
                if (syncUtils && regionOptions.start !== undefined) {
                  syncUtils.syncSeekToVLC(regionOptions.start, 'region-created');
                }
                
                return region;
              }
              return null;
            } catch (error) {
              console.error("Error creating region:", error);
              return null;
            }
          };
          
          console.log("All plugins registered successfully");
          
          // Update state
          setLoading(false);
          setIsAudioLoaded(true);
          
          // Notify parent component
          if (onReady) {
            onReady(wavesurfer);
          }
          
        } catch (error) {
          console.error("Error registering plugins:", error);
          // Reset flag on error so we can try again
          pluginsRegisteredRef.current = false;
        }
      };
      
      // Register plugins with a small delay to ensure DOM is ready
      setTimeout(registerPlugins, 100);
    }
    
    // Cleanup function
    return () => {
      if (wavesurfer && wavesurferInstanceRef.current === wavesurfer) {
        try {
          wavesurfer.un('interaction');
          wavesurfer.un('seeking');
          wavesurfer.un('timeupdate');
          wavesurfer.un('play');
          wavesurfer.un('pause');
        } catch (error) {
          console.warn("Error during cleanup:", error);
        }
      }
    };
    
  }, [wavesurfer, isReady, handleRegionIn, handleRegionOut, handleRegionClick, handleRegionUpdated, handleWaveformClick, onReady, randomColor, vlcSyncUtils]);
  
  // Reset plugin flag when audio file changes
  useEffect(() => {
    if (audioFile !== currentAudioFileRef.current) {
      pluginsRegisteredRef.current = false;
    }
  }, [audioFile]);
  
  // Update playback status
  useEffect(() => {
    if (wavesurfer && isReady && isAudioLoaded) {
      try {
        const wsIsPlaying = wavesurfer.isPlaying();
        
        if (isPlaying && !wsIsPlaying) {
          wavesurfer.play();
        } else if (!isPlaying && wsIsPlaying) {
          wavesurfer.pause();
        }
      } catch (error) {
        console.error("Error updating playback status:", error);
      }
    }
  }, [isPlaying, wavesurfer, isReady, isAudioLoaded]);
  
  // Safe zoom function
  const safeZoom = useCallback((level) => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    try {
      wavesurfer.zoom(level);
    } catch (error) {
      console.warn("Zoom error:", error);
    }
  }, [wavesurfer, isReady, isAudioLoaded]);
  
  // Update zoom level
  useEffect(() => {
    if (!isAudioLoaded || !isReady || !wavesurfer) return;
    
    if (lastZoomLevelRef.current !== zoomLevel) {
      lastZoomLevelRef.current = zoomLevel;
      
      const zoomTimer = setTimeout(() => {
        safeZoom(zoomLevel);
      }, 100);
      
      return () => clearTimeout(zoomTimer);
    }
  }, [zoomLevel, isAudioLoaded, isReady, wavesurfer, safeZoom]);
  
  // v1.0.13 - Update playback speed with VLC sync
  useEffect(() => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    if (lastPlaybackSpeedRef.current !== playbackSpeed) {
      lastPlaybackSpeedRef.current = playbackSpeed;
      
      try {
        // Update WaveSurfer speed
        wavesurfer.setPlaybackRate(playbackSpeed);
        console.log(`âš¡ WaveSurfer speed changed to: ${playbackSpeed}x`);
        
        // v1.0.13 - Sync speed to VLC immediately
        const syncUtils = vlcSyncUtils(wavesurfer);
        if (syncUtils) {
          syncUtils.syncSpeedToVLC(playbackSpeed, 'speed-change');
        }
        
      } catch (error) {
        console.error("Error setting playback speed:", error);
      }
    }
  }, [playbackSpeed, wavesurfer, isReady, isAudioLoaded, vlcSyncUtils]);
  
  // v1.0.11 - DISABLED aggressive VLC sync monitoring to prevent stuttering
  const setupExactVLCMirroring = useCallback(() => {
    if (!wavesurfer || !wavesurfer.vlc || !wavesurfer.vlc.isConnected()) {
      setVlcSyncStatus('disconnected');
      return null;
    }
    
    console.log("ðŸŽ¯ Setting up SIMPLIFIED VLC mirroring system");
    vlcSyncActiveRef.current = true;
    setVlcSyncStatus('connected');
    
    // v1.0.11 - DISABLED continuous monitoring to prevent stuttering
    // Only sync on explicit user interactions now
    console.log("âœ… SIMPLIFIED VLC mirroring system active (no continuous monitoring)");
    
    // Return cleanup function
    return () => {
      console.log("ðŸ§¹ Cleaning up VLC mirroring");
      vlcSyncActiveRef.current = false;
      setVlcSyncStatus('disconnected');
      
      if (vlcSyncIntervalRef.current) {
        clearInterval(vlcSyncIntervalRef.current);
        vlcSyncIntervalRef.current = null;
      }
    };
  }, [wavesurfer]);
  
  // v1.0.11 - Set up exact VLC mirroring when VLC becomes available
  useEffect(() => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    // Check if VLC is connected
    if (wavesurfer.vlc && wavesurfer.vlc.isConnected()) {
      const cleanup = setupExactVLCMirroring();
      return cleanup;
    }
    
    // If VLC is not connected yet, check periodically
    const vlcCheckInterval = setInterval(() => {
      if (wavesurfer.vlc && wavesurfer.vlc.isConnected()) {
        clearInterval(vlcCheckInterval);
        setupExactVLCMirroring();
      }
    }, 1000);
    
    return () => {
      clearInterval(vlcCheckInterval);
    };
  }, [wavesurfer, isReady, isAudioLoaded, setupExactVLCMirroring]);
  
  // v1.0.14 - MANUAL mute control - user decides when to mute WaveSurfer for sync checking
  useEffect(() => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    try {
      // ONLY respect user's manual mute setting - NO auto-muting
      if (isMuted) {
        wavesurfer.setVolume(0);
        console.log("ðŸ”‡ WaveSurfer MANUALLY MUTED (user choice for sync check)");
      } else {
        wavesurfer.setVolume(1);
        console.log("ðŸ”Š WaveSurfer UNMUTED (both audio sources active)");
      }
    } catch (error) {
      console.error("Error setting WaveSurfer volume:", error);
    }
  }, [isMuted, wavesurfer, isReady, isAudioLoaded]);
  
  // v1.0.11 - SIMPLIFIED Play/Pause handler to prevent conflicts
  const handlePlayPause = useCallback(() => {
    if (wavesurfer && isReady && isAudioLoaded) {
      try {
        console.log("ðŸŽµ Play/Pause button clicked - SIMPLIFIED SYNC");
        
        // Get current state BEFORE making changes
        const currentlyPlaying = wavesurfer.isPlaying();
        
        // Handle region playback first
        if (activeRegionRef.current) {
          console.log("ðŸŽµ Playing active region");
          activeRegionRef.current.play();
          
          // Sync VLC to region without state conflicts
          const syncUtils = vlcSyncUtils(wavesurfer);
          if (syncUtils) {
            syncUtils.syncRegionToVLC(activeRegionRef.current, 'play-pause-region');
          }
        } else {
          // Normal play/pause
          console.log(`ðŸŽµ Toggle play/pause - currently: ${currentlyPlaying ? 'playing' : 'paused'}`);
          wavesurfer.playPause();
        }
        
        // Update parent component with the NEW state (opposite of current)
        if (onPlayPause) {
          onPlayPause(!currentlyPlaying);
        }
      } catch (error) {
        console.error("Error toggling play/pause:", error);
      }
    }
  }, [wavesurfer, isReady, isAudioLoaded, onPlayPause, vlcSyncUtils]);
  
  // v1.0.11 - Enhanced keyboard shortcut with exact VLC sync
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.code === 'Space' && wavesurfer && isReady && isAudioLoaded) {
        e.preventDefault();
        handlePlayPause();
      }
      
      // v1.0.11 - Additional keyboard shortcuts for exact VLC control
      if (wavesurfer && isReady && isAudioLoaded) {
        const syncUtils = vlcSyncUtils(wavesurfer);
        
        switch (e.code) {
          case 'ArrowLeft':
            if (e.ctrlKey) {
              e.preventDefault();
              const currentTime = wavesurfer.getCurrentTime();
              const newTime = Math.max(0, currentTime - 5); // Seek back 5s
              const duration = wavesurfer.getDuration();
              if (duration && duration > 0) {
                wavesurfer.seekTo(newTime / duration);
                if (syncUtils) {
                  syncUtils.syncSeekToVLC(newTime, 'keyboard-seek-back');
                }
              }
            }
            break;
            
          case 'ArrowRight':
            if (e.ctrlKey) {
              e.preventDefault();
              const currentTime = wavesurfer.getCurrentTime();
              const duration = wavesurfer.getDuration();
              if (duration && duration > 0) {
                const newTime = Math.min(duration, currentTime + 5); // Seek forward 5s
                wavesurfer.seekTo(newTime / duration);
                if (syncUtils) {
                  syncUtils.syncSeekToVLC(newTime, 'keyboard-seek-forward');
                }
              }
            }
            break;
            
          case 'Home':
            e.preventDefault();
            wavesurfer.seekTo(0);
            if (syncUtils) {
              syncUtils.syncSeekToVLC(0, 'keyboard-home');
            }
            break;
            
          case 'End':
            e.preventDefault();
            const duration = wavesurfer.getDuration();
            if (duration && duration > 0) {
              wavesurfer.seekTo(0.99); // Almost to end
              if (syncUtils) {
                syncUtils.syncSeekToVLC(duration * 0.99, 'keyboard-end');
              }
            }
            break;
            
          default:
            // v1.0.11 - Added default case to fix ESLint warning
            break;
        }
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [wavesurfer, isReady, isAudioLoaded, handlePlayPause, vlcSyncUtils]);
  
  // v1.0.11 - Cleanup VLC sync on unmount
  useEffect(() => {
    return () => {
      if (vlcSyncIntervalRef.current) {
        clearInterval(vlcSyncIntervalRef.current);
      }
      if (pendingVlcSeekRef.current) {
        clearTimeout(pendingVlcSeekRef.current);
      }
    };
  }, []);
  
  return (
    <div className="waveform-wrapper">
      {/* v1.0.11 - Added VLC sync status indicator */}
      {vlcSyncStatus === 'connected' && (
        <div style={{
          position: 'absolute',
          top: '10px',
          right: '10px',
          background: 'rgba(40, 167, 69, 0.8)',
          color: 'white',
          padding: '4px 8px',
          borderRadius: '4px',
          fontSize: '0.8rem',
          zIndex: 1000
        }}>
          ðŸŽ¯ VLC EXACT SYNC
        </div>
      )}
      
      {/* Single container for waveform, spectrogram and timeline */}
      <div id="waveform-container" ref={containerRef} style={{
        width: '100%',
        marginBottom: '20px',
        backgroundColor: '#1a1a1a',
        borderRadius: '5px',
        boxShadow: '0 4px 10px rgba(0, 0, 0, 0.3)',
        position: 'relative',
        height: '560px',
        overflow: 'visible'
      }}>
        {/* Loading spinner overlay */}
        {loading && (
          <div id="spectrogram-loading" className="loading-container">
            <div className="simple-spinner"></div>
            <div className="loading-text">Loading Audio...</div>
          </div>
        )}
        
        {/* Message when no audio is loaded */}
        {!loading && !isAudioLoaded && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#6c757d'
          }}>
            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>
              <i className="fas fa-music"></i>
            </div>
            <h3>No Audio Loaded</h3>
            <p>Upload an audio file to visualize the waveform and spectrogram.</p>
          </div>
        )}
      </div>
      
      {/* Minimap for navigation - separate container */}
      <div id="minimap" ref={minimapRef} style={{
        width: '100%',
        height: '40px',
        marginBottom: '20px',
        backgroundColor: '#1a1a1a',
        borderRadius: '5px',
        boxShadow: '0 4px 10px rgba(0, 0, 0, 0.3)'
      }}></div>
      
      {/* Display current time */}
      {isReady && isAudioLoaded && (
        <div className="current-time" style={{ textAlign: 'center', marginBottom: '10px' }}>
          Time: {formatTime(currentTime)} / {formatTime(wavesurfer?.getDuration() || 0)}
          {/* v1.0.11 - Show sync status in time display */}
          {vlcSyncStatus === 'connected' && (
            <span style={{ marginLeft: '10px', color: '#28a745', fontSize: '0.8rem' }}>
              ðŸŽ¯ SYNCED
            </span>
          )}
        </div>
      )}
    </div>
  );
};

// Helper function to format time in MM:SS
const formatTime = (seconds) => {
  if (!seconds && seconds !== 0) return '--:--';
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
};

export default WaveSurferComponent;

================================================================================
File: src/index.js
================================================================================

/**
 * File: src/index.js
 * Description: Application entry point
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 * v1.0.1 (2025-05-19) - Added error handling and version logging
 * v1.0.2 (2025-05-19) - Fixed ESLint warning about unused import
 */

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './app';

// Add global error handler to catch unhandled errors
window.addEventListener('error', (event) => {
  console.error('Uncaught runtime error:', event.error);
});

// Log the React version to verify
console.log("React version:", React.version);

// Create root and render app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
