# Project Files Review
# Generated: 2025-05-19T16-05-24.107Z
# Total files: 16


================================================================================
File: implemetation guide.md
================================================================================

# How to Implement the WaveSurfer React Solution

This guide will help you implement the WaveSurfer visualization with the official `@wavesurfer/react` hook, which will solve the initialization and cleanup issues you've been experiencing.

## Step 1: Update package.json and install dependencies

1. Replace your `package.json` with the updated version that includes `@wavesurfer/react` and `wavesurfer.js`:

```json
{
  "name": "wavesurfer-react",
  "version": "1.0.0",
  "description": "WaveSurfer with Regions - React Implementation",
  "private": true,
  "dependencies": {
    "@wavesurfer/react": "^1.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "wavesurfer.js": "^7.9.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

2. Install the dependencies:

```bash
npm install
```

## Step 2: Update the components

1. Replace your `src/components/WaveSurferComponent.js` with the new version that uses `@wavesurfer/react`
2. Replace your `src/App.js` with the updated version
3. Keep your existing `src/components/StatusBar.js` and `src/components/UploadPanel.js` as they are
4. Keep your CSS files as they are

## Step 3: Remove script tags from index.html (optional)

Since we're now loading WaveSurfer.js through npm, you can remove the script tags from `public/index.html` if you want:

```html

```

Keeping them won't cause any issues, but they're redundant now.

## Step 4: Start the development server

```bash
npm start
```

## Why This Works Better

The `@wavesurfer/react` library is the official React integration for WaveSurfer.js, and it handles:

1. Proper initialization and cleanup of WaveSurfer.js instances
2. React lifecycle integration
3. Preventing memory leaks
4. Managing dependencies correctly

It gives us all the power of the original WaveSurfer.js library but handles the React-specific integration challenges automatically.

## Features Preserved from the Original HTML

This implementation maintains all the key features from your original HTML implementation:

- Waveform visualization
- Spectrogram
- Timeline
- Regions (creating by dragging, clicking to play)
- Minimap navigation
- Zoom controls
- Playback speed controls
- Region looping

The user interface and styling are also maintained to match your original implementation.


================================================================================
File: package.json
================================================================================

{
  "name": "wavesurfer-react",
  "version": "1.0.0",
  "description": "WaveSurfer with Regions - React Implementation",
  "private": true,
  "dependencies": {
    "@wavesurfer/react": "^1.0.4",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "wavesurfer.js": "^7.9.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

================================================================================
File: public/index.html
================================================================================

<!-- 
  File: public/index.html 
  Description: HTML entry point for the React application
  
  Version History:
  v1.0.0 (2025-05-18) - Initial implementation
  v1.0.1 (2025-05-18) - Added WaveSurfer scripts directly in HTML
-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="WaveSurfer with Regions - React Implementation"
    />
    <title>WaveSurfer with Regions</title>

    <!-- Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.15.4/css/all.css"
      integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm"
      crossorigin="anonymous"
    />

    <!-- WaveSurfer and plugins -->
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/wavesurfer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/spectrogram.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/timeline.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/hover.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/minimap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@7.9.4/dist/plugins/regions.min.js"></script>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      The React app will be mounted to the div with id="root".
    -->
  </body>
</html>


================================================================================
File: README.md
================================================================================

# WaveSurfer with Regions and VLC Player Integration

## Overview

This project integrates WaveSurfer.js audio visualization with VLC media player control. It provides:

1. Audio waveform visualization with WaveSurfer.js
2. Region selection and manipulation
3. VLC media player control via a web interface
4. Synchronization between WaveSurfer regions and VLC playback

The application allows users to visualize audio files, create regions by dragging on the waveform, and control VLC media player directly from the web interface.

## Features

- **Audio Visualization**: Display waveform and spectrogram
- **Region Management**: Create, edit, and remove regions on the waveform
- **VLC Integration**: Launch and control VLC from the web interface
- **Synchronization**: Click on a region to seek VLC to that position
- **Responsive Design**: Works on desktop and mobile devices

## Setup Instructions

### Prerequisites

- Node.js and npm installed
- VLC media player installed on your system
- React development environment

### Installation

1. Clone the repository:

   ```bash
   git clone <repository-url>
   cd wavesurfer-vlc-integration
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Install required packages:
   ```bash
   npm install @wavesurfer/react wavesurfer.js express body-parser
   ```

### Setup Backend for VLC Control

Create a server directory and add the backend files:

1. **Create Express server**:

   ```bash
   mkdir -p server
   cp src/backend-vlc-controller.js server/vlcController.js
   ```

2. **Create server.js file**:

   ```javascript
   const express = require('express');
   const bodyParser = require('body-parser');
   const vlcController = require('./vlcController');

   const app = express();
   const PORT = process.env.PORT || 3001;

   app.use(bodyParser.json());
   app.use('/api', vlcController);

   app.listen(PORT, () => {
     console.log(`Server running on port ${PORT}`);
   });
   ```

3. **Update package.json** to include server:
   ```json
   "scripts": {
     "start": "react-scripts start",
     "build": "react-scripts build",
     "server": "node server/server.js",
     "dev": "concurrently \"npm run server\" \"npm run start\""
   }
   ```

### Running the Application

1. Start the development environment:

   ```bash
   npm run dev
   ```

2. Access the application at http://localhost:3000

## Usage

1. **Upload an audio file** using the upload panel
2. **Visualize the audio** in the waveform and spectrogram
3. **Create regions** by dragging on the waveform
4. **Launch VLC** using the VLC button in the controls
5. **Control playback** using both WaveSurfer and VLC controls
6. **Click on regions** to seek VLC to that position

## Components Structure

- **App.js**: Main application component
- **WaveSurferComponent.js**: Audio visualization and region management
- **VLCController.js**: VLC media player control interface
- **UploadPanel.js**: File upload interface
- **StatusBar.js**: Application status display

## VLC Integration

The application communicates with VLC using its RC (Remote Control) interface. When you launch VLC from the web interface, it starts with the following parameters:

```
--extraintf rc --rc-host localhost:9999 --no-video-title-show
```

The backend server then communicates with VLC through this RC interface to control playback, seek to specific positions, adjust volume, etc.

## Customization

- Update the color scheme in CSS files
- Adjust the WaveSurfer visualization parameters in WaveSurferComponent.js
- Modify the VLC controller commands in VLCController.js
- Change the layout in App.js

## Credits

- WaveSurfer.js: https://wavesurfer-js.org/
- VLC Media Player: https://www.videolan.org/
- React: https://reactjs.org/

## License

MIT License


================================================================================
File: scan_project.js
================================================================================

/**
 * File: scan_project.js
 * Description: Script to scan all project files and output their contents for review
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 */

const fs = require('fs');
const path = require('path');

// Directories to exclude
const excludeDirs = ['node_modules', '.git', 'build', 'dist'];

// Files to exclude
const excludeFiles = ['.DS_Store', '.gitignore', 'package-lock.json'];

// File extensions to include
const includeExtensions = ['.js', '.jsx', '.html', '.css', '.json', '.md'];

// Configuration
const outputFile = 'project_files_review.txt';
const startDir = '.'; // Current directory

// Helper function to check if a file should be included
function shouldIncludeFile(filePath) {
  const fileName = path.basename(filePath);
  
  // Skip excluded files
  if (excludeFiles.includes(fileName)) {
    return false;
  }
  
  // Check file extension
  const ext = path.extname(filePath).toLowerCase();
  if (!includeExtensions.includes(ext)) {
    return false;
  }
  
  return true;
}

// Helper function to scan a directory recursively
function scanDirectory(dir, output) {
  try {
    // Read directory contents
    const items = fs.readdirSync(dir);
    
    // Process each item
    for (const item of items) {
      const itemPath = path.join(dir, item);
      const stat = fs.statSync(itemPath);
      
      // Process directories
      if (stat.isDirectory()) {
        // Skip excluded directories
        if (excludeDirs.includes(item)) {
          continue;
        }
        
        // Recursively scan subdirectories
        scanDirectory(itemPath, output);
      } 
      // Process files
      else if (stat.isFile() && shouldIncludeFile(itemPath)) {
        // Read file content
        const content = fs.readFileSync(itemPath, 'utf8');
        
        // Add to output
        output.push({
          path: itemPath,
          content: content
        });
      }
    }
  } catch (error) {
    console.error(`Error scanning directory ${dir}:`, error);
  }
}

// Main function
function main() {
  // Get current date and time
  const now = new Date().toISOString().replace(/:/g, '-');
  
  console.log(`Starting project scan at: ${now}`);
  console.log(`Output will be saved to: ${outputFile}`);
  
  // Collect all files
  const files = [];
  scanDirectory(startDir, files);
  
  // Sort files by path
  files.sort((a, b) => a.path.localeCompare(b.path));
  
  // Create output
  let output = `# Project Files Review\n`;
  output += `# Generated: ${now}\n`;
  output += `# Total files: ${files.length}\n\n`;
  
  // Add each file
  files.forEach((file, index) => {
    output += `\n${'='.repeat(80)}\n`;
    output += `File: ${file.path}\n`;
    output += `${'='.repeat(80)}\n\n`;
    output += file.content;
    output += '\n';
  });
  
  // Write output to file
  fs.writeFileSync(outputFile, output);
  
  console.log(`Scan complete. Found ${files.length} files.`);
  console.log(`Output saved to: ${outputFile}`);
}

// Run the script
main();

================================================================================
File: server/vlcController.js
================================================================================

/**
 * File: server/vlcController.js
 * Description: Backend API for VLC controller
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation based on Dash-VLC controller
 */

const express = require('express');
const { spawn } = require('child_process');
const net = require('net');
const fs = require('fs');
const path = require('path');
const os = require('os');
const router = express.Router();

// Global variables to store state
let vlcProcess = null;
let isPlaying = false;
let currentMediaPath = null;

// VLC RC interface details
const VLC_HOST = 'localhost';
const VLC_PORT = 9999;

// Function to send command to VLC
const sendVLCCommand = async (command) => {
  return new Promise((resolve, reject) => {
    try {
      const client = new net.Socket();
      
      client.on('error', (err) => {
        reject(`Connection error: ${err.message}`);
      });
      
      client.connect(VLC_PORT, VLC_HOST, () => {
        client.write(`${command}\n`);
      });
      
      client.on('data', (data) => {
        const response = data.toString().trim();
        client.destroy();
        resolve(response);
      });
      
      // Set timeout to avoid hanging
      setTimeout(() => {
        client.destroy();
        reject('Connection timeout');
      }, 3000);
      
    } catch (error) {
      reject(`Error sending command: ${error.message}`);
    }
  });
};

// API endpoint for launching VLC
router.post('/launch-vlc', async (req, res) => {
  try {
    const { mediaPath } = req.body;
    
    // Validate media path
    if (!mediaPath || !fs.existsSync(mediaPath)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid media path or file not found' 
      });
    }
    
    // Kill any existing VLC process
    if (vlcProcess !== null) {
      try {
        vlcProcess.kill();
        // Wait for process to terminate
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.error(`Error terminating VLC process: ${error.message}`);
      }
    }
    
    // Determine VLC path based on OS
    let vlcPath;
    if (process.platform === 'win32') {  // Windows
      const windowsPaths = [
        'C:\\Program Files\\VideoLAN\\VLC\\vlc.exe',
        'C:\\Program Files (x86)\\VideoLAN\\VLC\\vlc.exe'
      ];
      
      for (const path of windowsPaths) {
        if (fs.existsSync(path)) {
          vlcPath = path;
          break;
        }
      }
      
      if (!vlcPath) vlcPath = 'vlc';  // Try using PATH
    } else if (process.platform === 'darwin') {  // macOS
      if (fs.existsSync('/Applications/VLC.app/Contents/MacOS/VLC')) {
        vlcPath = '/Applications/VLC.app/Contents/MacOS/VLC';
      } else {
        vlcPath = 'vlc';  // Try using PATH
      }
    } else {  // Linux
      vlcPath = 'vlc';  // Try using PATH
    }
    
    // Launch VLC with RC interface
    vlcProcess = spawn(vlcPath, [
      '--extraintf', 'rc',
      '--rc-host', `${VLC_HOST}:${VLC_PORT}`,
      '--no-video-title-show',  // No title overlay
      mediaPath
    ]);
    
    // Handle process events
    vlcProcess.on('error', (error) => {
      console.error(`VLC process error: ${error.message}`);
      vlcProcess = null;
    });
    
    vlcProcess.on('exit', (code) => {
      console.log(`VLC process exited with code ${code}`);
      vlcProcess = null;
    });
    
    // Wait for VLC to initialize
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Immediately pause
    await sendVLCCommand('pause');
    isPlaying = false;
    currentMediaPath = mediaPath;
    
    res.json({ 
      success: true, 
      message: 'VLC launched successfully' 
    });
    
  } catch (error) {
    console.error(`Error launching VLC: ${error.message}`);
    res.status(500).json({ 
      success: false, 
      message: `Error launching VLC: ${error.message}` 
    });
  }
});

// API endpoint for sending commands to VLC
router.post('/vlc-command', async (req, res) => {
  try {
    const { command } = req.body;
    
    if (!command) {
      return res.status(400).json({ 
        success: false, 
        message: 'No command provided' 
      });
    }
    
    if (!vlcProcess) {
      return res.status(400).json({ 
        success: false, 
        message: 'VLC is not running' 
      });
    }
    
    const response = await sendVLCCommand(command);
    
    // Update state based on command
    if (command === 'pause') {
      isPlaying = !isPlaying;
    }
    
    res.json({ 
      success: true, 
      response,
      playerState: {
        isPlaying,
        currentMediaPath
      }
    });
    
  } catch (error) {
    console.error(`Error sending command to VLC: ${error.message}`);
    res.status(500).json({ 
      success: false, 
      message: `Error sending command: ${error.message}` 
    });
  }
});

// API endpoint for checking VLC status
router.get('/vlc-status', (req, res) => {
  res.json({
    isRunning: vlcProcess !== null,
    isPlaying,
    currentMediaPath
  });
});

module.exports = router;

================================================================================
File: src/app.js
================================================================================

/**
 * File: src/App.js
 * Description: Main application component with integrated controls
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation based on original HTML
 * v1.0.1 (2025-05-19) - Updated to use @wavesurfer/react
 * v1.0.2 (2025-05-19) - Removed loop regions checkbox, set loopRegions to true
 * v1.0.3 (2025-05-19) - Integrated VLC controller with all controls in one row
 */

import React, { useState, useRef, useEffect } from 'react';
import WaveSurferComponent from './components/WaveSurferComponent';
import VLCController from './components/VLCController';
import StatusBar from './components/StatusBar';
import UploadPanel from './components/UploadPanel';
import './assets/styles/main.css';
import './assets/styles/integrated-controls.css';

function App() {
  // State
  const [audioFile, setAudioFile] = useState(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [fileName, setFileName] = useState("");
  const [isReady, setIsReady] = useState(false);
  const [zoomLevel, setZoomLevel] = useState(100);
  const [playbackSpeed, setPlaybackSpeed] = useState(1.0);
  // Set loopRegions to true - regions will always loop
  const loopRegions = true;
  const [status, setStatus] = useState({ text: "No audio loaded", type: "info" });
  const [alert, setAlert] = useState({ message: "", isOpen: false, type: "info" });
  const [activeRegion, setActiveRegion] = useState(null);
  const [filePath, setFilePath] = useState(null);
  
  // Refs
  const wavesurferRef = useRef(null);
  
  // Handler for file uploads
  const handleFileUpload = (file) => {
    if (!file) return;
    
    setAudioFile(file);
    setFileName(file.name);
    setIsPlaying(false);
    setIsReady(false);
    setStatus({ text: "Loading...", type: "warning" });
    setAlert({ message: `File uploaded: ${file.name}`, isOpen: true, type: "success" });
    
    // Create a path for VLC to use (in a real implementation, this would be a server-side path)
    if (file instanceof File) {
      const url = URL.createObjectURL(file);
      setFilePath(url);
    } else {
      setFilePath(file);
    }
  };
  
  // Handler for play/pause
  const handlePlayPause = (isCurrentlyPlaying) => {
    // If isCurrentlyPlaying is provided, use it, otherwise toggle
    const newPlayingState = isCurrentlyPlaying !== undefined ? isCurrentlyPlaying : !isPlaying;
    setIsPlaying(newPlayingState);
    
    setAlert({
      message: newPlayingState ? "Audio playing" : "Audio paused",
      isOpen: true,
      type: "info"
    });
  };
  
  // Handler for WaveSurfer ready event
  const handleReady = (wavesurfer) => {
    wavesurferRef.current = wavesurfer;
    setIsReady(true);
    setStatus({ text: `Loaded: ${fileName}`, type: "success" });
  };
  
  // Handler for zoom in
  const handleZoomIn = () => {
    const newZoom = Math.min(1000, zoomLevel + 50);
    setZoomLevel(newZoom);
  };
  
  // Handler for zoom out
  const handleZoomOut = () => {
    const newZoom = Math.max(10, zoomLevel - 50);
    setZoomLevel(newZoom);
  };
  
  // Handler for reset zoom
  const handleResetZoom = () => {
    setZoomLevel(100);
  };
  
  // Handler for clear regions
  const handleClearRegions = () => {
    if (!wavesurferRef.current) {
      console.error("WaveSurfer instance not available");
      setAlert({ message: "Cannot clear regions: Player not initialized", isOpen: true, type: "danger" });
      return;
    }
    
    try {
      console.log("Attempting to clear regions...");
      
      // Try direct access to regions plugin
      if (wavesurferRef.current.regions) {
        console.log("Found regions plugin:", wavesurferRef.current.regions);
        wavesurferRef.current.regions.clearRegions();
        setAlert({ message: "All regions cleared", isOpen: true, type: "success" });
        // Reset active region
        setActiveRegion(null);
      } else {
        // Try to find the regions plugin in active plugins
        const regionsPlugin = wavesurferRef.current.getActivePlugins().find(
          plugin => plugin.name === 'regions' || plugin.params?.name === 'regions'
        );
        
        if (regionsPlugin) {
          console.log("Found regions plugin:", regionsPlugin);
          regionsPlugin.clearRegions();
          setAlert({ message: "All regions cleared", isOpen: true, type: "success" });
          // Reset active region
          setActiveRegion(null);
        } else {
          console.error("Regions plugin not found");
          setAlert({ message: "Could not clear regions", isOpen: true, type: "danger" });
        }
      }
    } catch (error) {
      console.error("Error clearing regions:", error);
      setAlert({ message: "Error clearing regions", isOpen: true, type: "danger" });
    }
  };
  
  // Handler for region activation
  const handleRegionActivated = (region) => {
    setActiveRegion(region);
  };
  
  // Handler for VLC status changes
  const handleVLCStatusChange = (vlcStatus) => {
    // Synchronize WaveSurfer playback with VLC if needed
    if (vlcStatus.isPlaying !== isPlaying) {
      setIsPlaying(vlcStatus.isPlaying);
    }
  };
  
  // Handler for VLC errors
  const handleVLCError = (error) => {
    setAlert({ message: error, isOpen: true, type: "danger" });
  };
  
  // Close alert after 3 seconds
  useEffect(() => {
    if (alert.isOpen) {
      const timer = setTimeout(() => {
        setAlert(prev => ({ ...prev, isOpen: false }));
      }, 3000);
      
      return () => clearTimeout(timer);
    }
  }, [alert.isOpen]);
  
  return (
    <div className="container">
      <h1>WaveSurfer with Regions and VLC</h1>
      
      <StatusBar status={status.text} type={status.type} />
      
      <UploadPanel onFileUpload={handleFileUpload} />
      
      <WaveSurferComponent
        audioFile={audioFile}
        isPlaying={isPlaying}
        loopRegions={loopRegions}
        zoomLevel={zoomLevel}
        playbackSpeed={playbackSpeed}
        onPlayPause={handlePlayPause}
        onReady={handleReady}
        onRegionActivated={handleRegionActivated}
      />
      
      <div className="all-controls">
        {/* First row: sliders for zoom and speed */}
        <div className="controls-row">
          {/* Zoom control slider */}
          <div className="slider-container">
            <span className="slider-label">Zoom:</span>
            <input
              type="range"
              id="zoom-slider"
              min="10"
              max="1000"
              value={zoomLevel}
              onChange={(e) => setZoomLevel(Number(e.target.value))}
            />
            <span id="zoom-value" className="slider-value">{zoomLevel}</span>
          </div>

          {/* Playback speed control slider */}
          <div className="slider-container">
            <span className="slider-label">Speed:</span>
            <input
              type="range"
              id="speed-slider"
              min="0.5"
              max="3"
              step="0.1"
              value={playbackSpeed}
              onChange={(e) => setPlaybackSpeed(Number(e.target.value))}
            />
            <span id="speed-value" className="slider-value">{playbackSpeed.toFixed(1)}x</span>
          </div>
        </div>
        
        {/* Second row: combined WaveSurfer and VLC controls */}
        <div className="main-controls">
          {/* WaveSurfer control buttons */}
          <div className="player-buttons">
            <button id="play-pause" onClick={() => handlePlayPause()}>
              {isPlaying ? 'Pause' : 'Play'}
            </button>
            <button id="zoom-in" onClick={handleZoomIn} disabled={!isReady}>
              Zoom In
            </button>
            <button id="zoom-out" onClick={handleZoomOut} disabled={!isReady}>
              Zoom Out
            </button>
            <button id="reset-zoom" onClick={handleResetZoom} disabled={!isReady}>
              Reset Zoom
            </button>
            <button id="clear-regions" className="danger" onClick={handleClearRegions} disabled={!isReady}>
              Clear Regions
            </button>
          </div>
          
          {/* VLC controls section */}
          <div className="vlc-section">
            <VLCController
              mediaFile={filePath}
              wavesurferInstance={wavesurferRef.current}
              activeRegion={activeRegion}
              onStatusChange={handleVLCStatusChange}
              onError={handleVLCError}
            />
          </div>
        </div>
      </div>
      
      {alert.isOpen && (
        <div className={`alert alert-${alert.type}`}>
          {alert.message}
        </div>
      )}
    </div>
  );
}

export default App;

================================================================================
File: src/assets/styles/integrated-controls.css
================================================================================

/**
 * File: src/assets/styles/integrated-controls.css
 * Description: CSS for the integrated controls row
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation
 */

.all-controls {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 1000px;
  margin: 20px auto;
}

/* Combined controls row with all controls in one line */
.controls-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 15px;
  background-color: #1d1919;
  border-radius: 25px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  margin-bottom: 15px;
}

.slider-container {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 200px;
  margin: 0 10px;
}

.slider-label {
  margin-right: 5px;
  min-width: 45px;
  white-space: nowrap;
  color: #adb5bd;
}

.slider-value {
  min-width: 35px;
  text-align: right;
  color: #0dcaf0;
}

input[type='range'] {
  flex-grow: 1;
  margin: 0 5px;
  height: 8px;
  border-radius: 4px;
  background: #555555;
  outline: none;
}

input[type='range']::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

input[type='range']::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

/* Main controls container */
.main-controls {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  width: 100%;
  background-color: #1d1919;
  border-radius: 25px;
  padding: 15px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

/* Player buttons */
.player-buttons {
  display: flex;
  flex-wrap: wrap;
  margin-right: 20px;
}

.player-buttons button {
  background-color: #4363ca;
  color: #ffffff;
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  margin: 0 5px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.player-buttons button:hover {
  background-color: #357ea8;
}

.player-buttons button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.player-buttons button.danger {
  background-color: #dc3545;
}

.player-buttons button.danger:hover {
  background-color: #c82333;
}

/* VLC controls */
.vlc-section {
  display: flex;
  align-items: center;
  flex: 1;
  margin-left: 20px;
  border-left: 1px solid #333;
  padding-left: 20px;
}

/* VLC button styles */
.vlc-controls button {
  background-color: transparent;
  color: #f8f9fa;
  border: none;
  padding: 8px 12px;
  margin: 0 5px;
  border-radius: 5px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.vlc-controls button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: #0dcaf0;
}

.vlc-controls button i {
  font-size: 1.2rem;
}

.vlc-launch {
  background-color: #dc3545 !important;
  color: #ffffff !important;
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  margin-right: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.vlc-launch:hover {
  background-color: #c82333 !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.vlc-launch:disabled {
  background-color: #6c757d !important;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.vlc-status {
  margin-left: auto;
  display: flex;
  align-items: center;
}

.status-label {
  color: #6c757d;
  margin-right: 8px;
}

.status-value {
  font-weight: bold;
}

.status-value.playing {
  color: #28a745;
}

.status-value.paused {
  color: #ffc107;
}

/* Alert message */
.alert {
  padding: 12px 16px;
  margin-top: 15px;
  border-radius: 8px;
  text-align: center;
  animation: fadeIn 0.3s ease-in;
}

.alert-info {
  background-color: rgba(13, 202, 240, 0.15);
  color: #0dcaf0;
}

.alert-success {
  background-color: rgba(40, 167, 69, 0.15);
  color: #28a745;
}

.alert-warning {
  background-color: rgba(255, 193, 7, 0.15);
  color: #ffc107;
}

.alert-danger {
  background-color: rgba(220, 53, 69, 0.15);
  color: #dc3545;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .main-controls {
    flex-direction: column;
  }

  .player-buttons,
  .vlc-section {
    width: 100%;
    margin: 10px 0;
    padding: 0;
    border-left: none;
  }

  .vlc-section {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #333;
  }

  .slider-container {
    flex-direction: column;
    align-items: flex-start;
  }

  .slider-label {
    margin-bottom: 5px;
  }

  .controls-row {
    flex-direction: column;
  }

  .vlc-controls {
    flex-wrap: wrap;
    justify-content: center;
  }
}


================================================================================
File: src/assets/styles/main.css
================================================================================

/**
 * File: src/assets/styles/main.css
 * Description: Main application styling
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation based on original HTML
 * v1.0.1 (2025-05-19) - Fixed corrupted CSS rule for waveform container
 * v1.0.2 (2025-05-19) - Updated container widths to 95% and fixed background colors
 */

body {
  background-color: #212529;
  color: #f8f9fa;
  font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  margin: 0;
  padding: 20px;
}

.container {
  max-width: 1200px; /* Slightly wider container */
  margin: 0 auto;
}

h1 {
  text-align: center;
  margin-bottom: 30px;
}

/* Card styling */
.card {
  background-color: #1a1a1a;
  border-radius: 5px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
  margin-bottom: 20px;
}

.card-body {
  padding: 20px;
}

/* Single container for waveform, spectrogram and timeline */
#waveform-container {
  width: 95% !important; /* Force 95% width */
  margin: 0 auto 20px auto !important; /* Center the container */
  background-color: #1a1a1a;
  border-radius: 5px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
  position: relative;
  /* Default height will include both waveform, spectrogram and timeline */
  height: 560px;
  /* Makes sure content is visible */
  overflow: visible !important;
}

/* Only keep minimap separate */
#minimap {
  width: 95% !important; /* Force 95% width */
  height: 40px;
  margin: 0 auto 20px auto !important; /* Center the minimap */
  background-color: #1a1a1a;
  border-radius: 5px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
}

/* Controls row */
.controls-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: space-between;
  width: 95%; /* Match waveform width */
  max-width: 1200px;
  margin: 20px auto;
  padding: 15px;
  background-color: #1d1919;
  border-radius: 25px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.slider-container {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 250px;
  margin: 0 10px;
}

.slider-label {
  margin-right: 5px;
  min-width: 45px;
  white-space: nowrap;
  color: #adb5bd;
}

.slider-value {
  min-width: 35px;
  text-align: right;
  color: #0dcaf0;
}

input[type='range'] {
  flex-grow: 1;
  margin: 0 5px;
  height: 8px;
  border-radius: 4px;
  background: #555555;
  outline: none;
}

input[type='range']::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

input[type='range']::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #4363ca;
  cursor: pointer;
}

.checkbox-container {
  display: flex;
  align-items: center;
  margin: 0 10px;
  min-width: 120px;
}

/* Player control buttons */
.controls {
  display: flex;
  justify-content: center;
  margin: 20px 0;
  flex-wrap: wrap;
  width: 95%; /* Match waveform width */
  margin: 20px auto;
}

button {
  background-color: #4363ca;
  color: #ffffff;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  margin: 5px 10px;
  cursor: pointer;
}

button:hover {
  background-color: #357ea8;
}

button.danger {
  background-color: #dc3545;
}

button.danger:hover {
  background-color: #c82333;
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Loading container */
.loading-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background-color: rgba(26, 26, 26, 0.8);
  z-index: 10;
  border-radius: 5px;
}

.simple-spinner {
  width: 40px;
  height: 40px;
  margin-bottom: 20px;
  border: 4px solid rgba(13, 202, 240, 0.2);
  border-top: 4px solid #0dcaf0;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.loading-text {
  color: #f8f9fa;
  font-size: 1.2rem;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Status styling */
.status {
  text-align: center;
  padding: 10px;
  margin: 10px 0;
  background-color: #222;
  border-radius: 5px;
  width: 95%; /* Match waveform width */
  margin: 10px auto;
}

.text-info {
  color: #0dcaf0 !important;
}

.text-success {
  color: #28a745 !important;
}

.text-warning {
  color: #ffc107 !important;
}

.text-danger {
  color: #dc3545 !important;
}

.fw-bold {
  font-weight: bold !important;
}

/* Alert message styling */
.alert {
  padding: 12px 16px;
  margin-top: 15px;
  border-radius: 8px;
  text-align: center;
  animation: fadeIn 0.3s ease-in;
  width: 95%; /* Match waveform width */
  margin: 15px auto;
}

.alert-info {
  background-color: rgba(13, 202, 240, 0.15);
  color: #0dcaf0;
}

.alert-success {
  background-color: rgba(40, 167, 69, 0.15);
  color: #28a745;
}

.alert-warning {
  background-color: rgba(255, 193, 7, 0.15);
  color: #ffc107;
}

.alert-danger {
  background-color: rgba(220, 53, 69, 0.15);
  color: #dc3545;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Utility classes */
.mb-4 {
  margin-bottom: 1.5rem !important;
}

.m-0 {
  margin: 0 !important;
}

.me-2 {
  margin-right: 0.5rem !important;
}

/* Current time display */
.current-time {
  text-align: center;
  margin-bottom: 10px;
  width: 95%; /* Match waveform width */
  margin: 0 auto 10px auto;
  color: #0dcaf0;
  font-weight: bold;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  #waveform-container {
    height: 400px;
  }

  .slider-container {
    flex-direction: column;
    align-items: flex-start;
  }

  .slider-label {
    margin-bottom: 5px;
  }

  .controls-row {
    flex-direction: column;
  }

  .checkbox-container {
    margin: 10px 0;
  }
}


================================================================================
File: src/assets/styles/upload-panel.css
================================================================================

/**
File: src/assets/styles/upload-panel.css
Description: Styling for the upload panel
Version History:
v1.0.0 (2025-05-18) - Initial implementation */
/* Upload toggle styling */

.upload-toggle {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  cursor: pointer;
  border-bottom: 1px solid #333;
  transition: background-color 0.2s ease;
}

.upload-toggle:hover {
  background-color: rgba(255, 255, 255, 0.05);
}

.upload-toggle-icon {
  transition: transform 0.3s;
}

.upload-toggle-icon.open {
  transform: rotate(180deg);
}

/* Upload area enhanced hover styling */
.upload-area {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
  border: 2px dashed #6c757d;
  border-radius: 10px;
  padding: 40px 20px;
  text-align: center;
  cursor: pointer;
  margin: 0 auto;
  max-width: 65%;
}

.upload-area:hover {
  transform: scale(1.03) !important;
  box-shadow: 0 8px 20px rgba(13, 202, 240, 0.2) !important;
  border-color: #0dcaf0 !important;
  background-color: rgba(13, 202, 240, 0.1) !important;
}

.upload-area.drag-active {
  border-color: #0dcaf0;
  background-color: rgba(13, 202, 240, 0.1);
  transform: scale(1.03);
}

#upload-icon {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
}

.upload-area:hover #upload-icon {
  transform: translateY(-8px) scale(1.1) !important;
  color: #0dcaf0 !important;
  filter: drop-shadow(0 5px 10px rgba(13, 202, 240, 0.3));
}

#upload-text {
  transition: all 0.4s ease !important;
}

.upload-area:hover #upload-text {
  transform: scale(1.05);
  color: #0dcaf0 !important;
  font-weight: bold !important;
}

/* Hidden file input */
.hidden-input {
  display: none;
}

/* File info display */
#file-info-display {
  text-align: center;
  padding: 10px 0;
}

/* Launch button enhanced hover */
.launch-btn {
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important;
}

.launch-btn:hover {
  transform: translateY(-3px) scale(1.03) !important;
  box-shadow: 0 8px 20px rgba(13, 202, 240, 0.4) !important;
  background-color: #0dcaf0 !important;
  letter-spacing: 0.5px;
}

.launch-btn:active {
  transform: translateY(1px) !important;
  box-shadow: 0 3px 10px rgba(13, 202, 240, 0.3) !important;
}

/* Utility classes */
.text-info-emphasis {
  color: #6c757d;
}

.fw-bold {
  font-weight: bold;
}

.small {
  font-size: 0.875rem;
}

.mt-1 {
  margin-top: 0.25rem;
}

.mt-2 {
  margin-top: 0.5rem;
}

.mt-4 {
  margin-top: 1.5rem;
}

.mb-3 {
  margin-bottom: 1rem;
}

.text-center {
  text-align: center;
}

.text-muted {
  color: #6c757d;
}

.text-light {
  color: #f8f9fa;
}

.text-success {
  color: #28a745;
}

/* Font Awesome icon overrides */
.fas {
  font-family: 'Font Awesome 5 Free';
}

.fa-3x {
  font-size: 3em;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .upload-area {
    max-width: 100%;
    padding: 20px 10px;
  }
}


================================================================================
File: src/assets/styles/vlc-controller.css
================================================================================

/**
 * File: src/assets/styles/vlc-controller.css
 * Description: Styles for VLC controller
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation
 */

.vlc-controls {
  display: flex;
  align-items: center;
  margin-top: 1rem;
  background-color: #1d1919;
  border-radius: 25px;
  padding: 12px 20px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

.vlc-launch {
  background-color: #dc3545;
  color: #ffffff;
  padding: 8px 15px;
  border: none;
  border-radius: 5px;
  margin-right: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.vlc-launch:hover {
  background-color: #c82333;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.vlc-launch:disabled {
  background-color: #6c757d;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.vlc-launch i {
  margin-right: 5px;
}

.vlc-playback-controls {
  display: flex;
  align-items: center;
  flex: 1;
}

.vlc-playback-controls.disabled {
  opacity: 0.6;
  pointer-events: none;
}

.vlc-playback-controls button {
  background-color: transparent;
  color: #f8f9fa;
  border: none;
  padding: 8px 12px;
  margin: 0 5px;
  border-radius: 5px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.vlc-playback-controls button:hover {
  background-color: rgba(255, 255, 255, 0.1);
  color: #0dcaf0;
}

.vlc-playback-controls button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.vlc-playback-controls button i {
  font-size: 1.2rem;
}

.vlc-status {
  margin-left: auto;
  display: flex;
  align-items: center;
}

.status-label {
  color: #6c757d;
  margin-right: 8px;
}

.status-value {
  font-weight: bold;
}

.status-value.not {
  color: #6c757d;
}

.status-value.ready {
  color: #0dcaf0;
}

.status-value.playing {
  color: #28a745;
}

.status-value.paused,
.status-value.stopped {
  color: #ffc107;
}

.status-value.error {
  color: #dc3545;
}

.vlc-alert {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 20px;
  border-radius: 5px;
  animation: slideIn 0.3s ease-out;
  z-index: 1000;
  max-width: 300px;
}

.alert-info {
  background-color: rgba(13, 202, 240, 0.2);
  border-left: 4px solid #0dcaf0;
  color: #0dcaf0;
}

.alert-success {
  background-color: rgba(40, 167, 69, 0.2);
  border-left: 4px solid #28a745;
  color: #28a745;
}

.alert-warning {
  background-color: rgba(255, 193, 7, 0.2);
  border-left: 4px solid #ffc107;
  color: #ffc107;
}

.alert-danger {
  background-color: rgba(220, 53, 69, 0.2);
  border-left: 4px solid #dc3545;
  color: #dc3545;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Make the VLC controls responsive */
@media (max-width: 768px) {
  .vlc-controls {
    flex-direction: column;
    padding: 15px;
  }

  .vlc-launch {
    margin-bottom: 15px;
    margin-right: 0;
    width: 100%;
  }

  .vlc-playback-controls {
    flex-wrap: wrap;
    justify-content: center;
  }

  .vlc-status {
    margin: 15px auto 0;
  }
}


================================================================================
File: src/components/StatusBar.js
================================================================================

/**
 * File: src/components/StatusBar.js
 * Description: Status indicator component
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 */

import React from 'react';

const StatusBar = ({ status, type }) => {
  return (
    <div className="status">
      <span className={`text-${type} fw-bold`}>
        Status: {status}
      </span>
    </div>
  );
};

export default StatusBar;

================================================================================
File: src/components/UploadPanel.js
================================================================================

/**
 * File: src/components/UploadPanel.js
 * Description: File upload panel component
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 */

import React, { useState, useRef } from 'react';
import '../assets/styles/upload-panel.css';

const UploadPanel = ({ onFileUpload }) => {
  const [isDragging, setIsDragging] = useState(false);
  const [uploadedFile, setUploadedFile] = useState(null);
  const [isCollapsed, setIsCollapsed] = useState(false);
  const fileInputRef = useRef(null);
  
  // Handle file selection
  const handleFileChange = (event) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      const file = files[0];
      handleFile(file);
    }
  };
  
  // Handle file drop
  const handleDrop = (event) => {
    event.preventDefault();
    setIsDragging(false);
    
    if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
      const file = event.dataTransfer.files[0];
      handleFile(file);
    }
  };
  
  // Process the uploaded file
  const handleFile = (file) => {
    // Check if file is audio or video
    const acceptedTypes = [
      'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/flac', 'audio/aac', 
      'video/mp4', 'video/webm', 'video/ogg', 'video/avi', 'video/mkv', 'video/mov'
    ];
    
    if (!acceptedTypes.includes(file.type)) {
      alert('Please upload an audio or video file.');
      return;
    }
    
    setUploadedFile(file);
    onFileUpload(file);
  };
  
  // Drag events
  const handleDragOver = (event) => {
    event.preventDefault();
    setIsDragging(true);
  };
  
  const handleDragLeave = () => {
    setIsDragging(false);
  };
  
  // Format file size
  const formatFileSize = (size) => {
    // Define size units
    const units = ["B", "KB", "MB", "GB", "TB"];
    
    // Calculate the appropriate unit
    let i = 0;
    let sizeBytes = size;
    while (sizeBytes >= 1024 && i < units.length - 1) {
      sizeBytes /= 1024;
      i++;
    }
    
    // Format the result with 2 decimal places if needed
    if (i > 0) {
      return `${sizeBytes.toFixed(2)} ${units[i]}`;
    } else {
      return `${sizeBytes} ${units[i]}`;
    }
  };
  
  // Get file type display
  const getFileTypeDisplay = (file) => {
    if (file.type.startsWith('audio/')) return 'audio';
    if (file.type.startsWith('video/')) return 'video';
    return 'file';
  };
  
  return (
    <div className="card mb-4">
      {/* Collapse toggle */}
      <div className="upload-toggle" onClick={() => setIsCollapsed(!isCollapsed)}>
        <h3 className="m-0">
          <i className="fas fa-file-upload me-2 text-info"></i>
          Upload Audio/Video
        </h3>
        <i className={`fas fa-chevron-down upload-toggle-icon ${isCollapsed ? '' : 'open'}`}></i>
      </div>
      
      {/* Collapsible content */}
      {!isCollapsed && (
        <div className="card-body">
          {/* Upload area */}
          <div 
            className={`upload-area ${isDragging ? 'drag-active' : ''}`}
            onClick={() => fileInputRef.current.click()}
            onDragOver={handleDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <i id="upload-icon" className="fas fa-file-upload fa-3x mb-3 text-info-emphasis"></i>
            <div id="upload-text" className="fw-bold">Drag and Drop or Click to Upload</div>
            <div className="text-muted small mt-1">Supports audio and video files up to 4GB</div>
            
            {/* Hidden file input */}
            <input
              ref={fileInputRef}
              type="file"
              className="hidden-input"
              accept="audio/*,video/*"
              onChange={handleFileChange}
              id="file-input"
            />
          </div>
          
          {/* Display file info if uploaded */}
          {uploadedFile && (
            <div id="file-info-display" className="text-light font-italic small mt-2">
              <i className="fas fa-check-circle text-success me-2"></i>
              Uploaded: {uploadedFile.name} ({formatFileSize(uploadedFile.size)}, {getFileTypeDisplay(uploadedFile)})
            </div>
          )}
          
          {/* Launch button - only show if file is uploaded */}
          {uploadedFile && (
            <div className="text-center">
              <button
                id="launch-vlc"
                className="mt-4 launch-btn fw-bold"
                style={{
                  fontSize: '1.2rem',
                  padding: '0.7rem 1.5rem',
                  borderRadius: '30px',
                  boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
                  transition: 'all 0.3s ease',
                  backgroundColor: '#4363ca',
                  color: 'white',
                  border: 'none',
                  cursor: 'pointer',
                }}
                onClick={() => onFileUpload(uploadedFile)} // Re-load the same file
              >
                <i className="fas fa-play-circle me-2"></i>
                Load Audio
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

export default UploadPanel;

================================================================================
File: src/components/VLCController.js
================================================================================

/**
 * File: src/components/VLCController.js
 * Description: VLC Media Player controller component
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Initial implementation based on Dash-VLC controller
 * v1.0.1 (2025-05-19) - Optimized for integration in main controls row
 */

import React, { useState, useEffect, useCallback } from 'react';

const VLCController = ({ 
  mediaFile, 
  onStatusChange,
  wavesurferInstance,
  activeRegion,
  onError
}) => {
  // State for the VLC controller
  const [isPlaying, setIsPlaying] = useState(false);
  const [status, setStatus] = useState('Not connected');
  const [vlcConnected, setVlcConnected] = useState(false);
  
  // VLC connection settings
  const VLC_HOST = 'localhost';
  const VLC_PORT = 9999;

  // Function to send commands to VLC via backend API
  const sendVLCCommand = useCallback(async (command) => {
    try {
      // In a real implementation, you would make an API call to your backend
      // For demonstration, we'll use a mock implementation
      console.log(`Sending VLC command: ${command}`);
      
      // Simulate a backend call
      const response = await fetch('/api/vlc-command', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ command })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to send command: ${response.statusText}`);
      }
      
      const result = await response.json();
      return result.response;
    } catch (error) {
      console.error(`Error sending command: ${error.message}`);
      if (onError) onError(`Error: ${error.message}`);
      return null;
    }
  }, [onError]);

  // Function to launch VLC
  const launchVLC = useCallback(async () => {
    if (!mediaFile) {
      if (onError) onError('Please upload a media file first');
      return;
    }

    try {
      // Make API call to backend to launch VLC
      const response = await fetch('/api/launch-vlc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mediaPath: mediaFile })
      });

      if (!response.ok) {
        throw new Error(`Failed to launch VLC: ${response.statusText}`);
      }

      const result = await response.json();
      
      if (result.success) {
        setVlcConnected(true);
        setStatus('Ready');
        
        // Pause immediately after launch
        await sendVLCCommand('pause');
        setIsPlaying(false);
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error(`Error launching VLC: ${error.message}`);
      if (onError) onError(`Error launching VLC: ${error.message}`);
      setStatus('Error');
    }
  }, [mediaFile, sendVLCCommand, onError]);

  // Play/Pause toggle
  const togglePlayPause = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('pause');
      const newPlayingState = !isPlaying;
      setIsPlaying(newPlayingState);
      setStatus(newPlayingState ? 'Playing' : 'Paused');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: newPlayingState });
      }
    } catch (error) {
      console.error(`Error toggling play/pause: ${error.message}`);
    }
  }, [vlcConnected, isPlaying, sendVLCCommand, onStatusChange]);

  // Stop playback
  const stopPlayback = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      // First pause then seek to beginning
      await sendVLCCommand('pause');
      await sendVLCCommand('seek 0');
      setIsPlaying(false);
      setStatus('Stopped');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: false });
      }
    } catch (error) {
      console.error(`Error stopping playback: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, onStatusChange]);

  // Seek backward/forward
  const seekMedia = useCallback(async (seconds) => {
    if (!vlcConnected) return;
    
    try {
      const command = `seek ${seconds > 0 ? '+' : ''}${seconds}`;
      await sendVLCCommand(command);
    } catch (error) {
      console.error(`Error seeking media: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Volume up/down
  const adjustVolume = useCallback(async (amount) => {
    if (!vlcConnected) return;
    
    try {
      const command = amount > 0 ? 'volup 5' : 'voldown 5';
      await sendVLCCommand(command);
    } catch (error) {
      console.error(`Error adjusting volume: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Toggle fullscreen
  const toggleFullscreen = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('fullscreen');
    } catch (error) {
      console.error(`Error toggling fullscreen: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Effect to handle active region changes
  useEffect(() => {
    if (!vlcConnected || !activeRegion || !wavesurferInstance) return;
    
    const handleRegionPlayback = async () => {
      try {
        // Seek to the region start time
        const startTime = activeRegion.start;
        await sendVLCCommand(`seek ${Math.floor(startTime)}`);
        
        // Resume playback if paused
        if (!isPlaying) {
          await sendVLCCommand('pause'); // VLC uses the same command to toggle play/pause
          setIsPlaying(true);
          setStatus('Playing region');
          
          // Notify parent component
          if (onStatusChange) {
            onStatusChange({ isPlaying: true });
          }
        }
      } catch (error) {
        console.error(`Error handling region playback: ${error.message}`);
      }
    };
    
    handleRegionPlayback();
  }, [activeRegion, vlcConnected, sendVLCCommand, wavesurferInstance, isPlaying, onStatusChange]);

  // Render compact VLC controller buttons
  return (
    <div className="vlc-controls">
      {/* Launch VLC Button */}
      <button 
        className="vlc-launch"
        onClick={launchVLC}
        disabled={!mediaFile || vlcConnected}
        title="Launch VLC Player"
      >
        <i className="fas fa-external-link-alt"></i> VLC
      </button>
      
      {/* Only show playback controls if VLC is connected */}
      {vlcConnected && (
        <>
          <button
            onClick={togglePlayPause}
            title={isPlaying ? 'Pause' : 'Play'}
          >
            <i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'}`}></i>
          </button>
          
          <button
            onClick={stopPlayback}
            title="Stop"
          >
            <i className="fas fa-stop"></i>
          </button>
          
          <button
            onClick={() => adjustVolume(-5)}
            title="Volume Down"
          >
            <i className="fas fa-volume-down"></i>
          </button>
          
          <button
            onClick={() => adjustVolume(5)}
            title="Volume Up"
          >
            <i className="fas fa-volume-up"></i>
          </button>
          
          <button
            onClick={() => seekMedia(-10)}
            title="Seek Backward 10s"
          >
            <i className="fas fa-backward"></i>
          </button>
          
          <button
            onClick={() => seekMedia(10)}
            title="Seek Forward 10s"
          >
            <i className="fas fa-forward"></i>
          </button>
          
          <button
            onClick={toggleFullscreen}
            title="Toggle Fullscreen"
          >
            <i className="fas fa-expand"></i>
          </button>
        </>
      )}
      
      {/* Status indicator */}
      <div className="vlc-status">
        <span className="status-label">VLC:</span>
        <span className={`status-value ${status.toLowerCase()}`}>{status}</span>
      </div>
    </div>
  );
};

export default VLCController;
File) {
      if (onError) onError('Please upload a media file first');
      return;
    }

    try {
      // Make API call to backend to launch VLC
      const response = await fetch('/api/launch-vlc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mediaPath: mediaFile })
      });

      if (!response.ok) {
        throw new Error(`Failed to launch VLC: ${response.statusText}`);
      }

      const result = await response.json();
      
      if (result.success) {
        setVlcConnected(true);
        setStatus('Ready');
        
        // Pause immediately after launch
        await sendVLCCommand('pause');
        setIsPlaying(false);
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error(`Error launching VLC: ${error.message}`);
      if (onError) onError(`Error launching VLC: ${error.message}`);
      setStatus('Error');
    }
  }, [mediaFile, sendVLCCommand, onError]);

  // Play/Pause toggle
  const togglePlayPause = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('pause');
      const newPlayingState = !isPlaying;
      setIsPlaying(newPlayingState);
      setStatus(newPlayingState ? 'Playing' : 'Paused');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: newPlayingState });
      }
    } catch (error) {
      console.error(`Error toggling play/pause: ${error.message}`);
    }
  }, [vlcConnected, isPlaying, sendVLCCommand, onStatusChange]);

  // Stop playback
  const stopPlayback = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      // First pause then seek to beginning
      await sendVLCCommand('pause');
      await sendVLCCommand('seek 0');
      setIsPlaying(false);
      setStatus('Stopped');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: false });
      }
    } catch (error) {
      console.error(`Error stopping playback: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, onStatusChange]);

  // Seek backward/forward
  const seekMedia = useCallback(async (seconds) => {
    if (!vlcConnected) return;
    
    try {
      const command = `seek ${seconds > 0 ? '+' : ''}${seconds}`;
      await sendVLCCommand(command);
    } catch (error) {
      console.error(`Error seeking media: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Volume up/down
  const adjustVolume = useCallback(async (amount) => {
    if (!vlcConnected) return;
    
    try {
      const command = amount > 0 ? 'volup 5' : 'voldown 5';
      await sendVLCCommand(command);
    } catch (error) {
      console.error(`Error adjusting volume: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Toggle fullscreen
  const toggleFullscreen = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('fullscreen');
    } catch (error) {
      console.error(`Error toggling fullscreen: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Effect to handle active region changes
  useEffect(() => {
    if (!vlcConnected || !activeRegion || !wavesurferInstance) return;
    
    const handleRegionPlayback = async () => {
      try {
        // Seek to the region start time
        const startTime = activeRegion.start;
        await sendVLCCommand(`seek ${Math.floor(startTime)}`);
        
        // Resume playback if paused
        if (!isPlaying) {
          await sendVLCCommand('pause'); // VLC uses the same command to toggle play/pause
          setIsPlaying(true);
          setStatus('Playing region');
          
          // Notify parent component
          if (onStatusChange) {
            onStatusChange({ isPlaying: true });
          }
        }
      } catch (error) {
        console.error(`Error handling region playback: ${error.message}`);
      }
    };
    
    handleRegionPlayback();
  }, [activeRegion, vlcConnected, sendVLCCommand, wavesurferInstance, isPlaying, onStatusChange]);

  // Render compact VLC controller buttons
  return (
    <div className="vlc-controls">
      {/* Launch VLC Button */}
      <button 
        className="vlc-launch"
        onClick={launchVLC}
        disabled={!mediaFile || vlcConnected}
        title="Launch VLC Player"
      >
        <i className="fas fa-external-link-alt"></i> VLC
      </button>
      
      {/* Only show playback controls if VLC is connected */}
      {vlcConnected && (
        <>
          <button
            onClick={togglePlayPause}
            title={isPlaying ? 'Pause' : 'Play'}
          >
            <i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'}`}></i>
          </button>
          
          <button
            onClick={stopPlayback}
            title="Stop"
          >
            <i className="fas fa-stop"></i>
          </button>
          
          <button
            onClick={() => adjustVolume(-5)}
            title="Volume Down"
          >
            <i className="fas fa-volume-down"></i>
          </button>
          
          <button
            onClick={() => adjustVolume(5)}
            title="Volume Up"
          >
            <i className="fas fa-volume-up"></i>
          </button>
          
          <button
            onClick={() => seekMedia(-10)}
            title="Seek Backward 10s"
          >
            <i className="fas fa-backward"></i>
          </button>
          
          <button
            onClick={() => seekMedia(10)}
            title="Seek Forward 10s"
          >
            <i className="fas fa-forward"></i>
          </button>
          
          <button
            onClick={toggleFullscreen}
            title="Toggle Fullscreen"
          >
            <i className="fas fa-expand"></i>
          </button>
        </>
      )}
      
      {/* Status indicator */}
      <div className="vlc-status">
        <span className="status-label">VLC:</span>
        <span className={`status-value ${status.toLowerCase()}`}>{status}</span>
      </div>
    </div>
  );
};

export default VLCController;
File, 
  onStatusChange,
  wavesurferInstance,
  activeRegion,
  onError
}) => {
  // State for the VLC controller
  const [isPlaying, setIsPlaying] = useState(false);
  const [status, setStatus] = useState('Not connected');
  const [vlcConnected, setVlcConnected] = useState(false);
  const [alertMessage, setAlertMessage] = useState(null);
  const [alertType, setAlertType] = useState('info');

  // VLC connection settings
  const VLC_HOST = 'localhost';
  const VLC_PORT = 9999;

  // Function to send commands to VLC via backend API
  const sendVLCCommand = useCallback(async (command) => {
    try {
      // In a real implementation, you would make an API call to your backend
      // For demonstration, we'll use a mock implementation
      console.log(`Sending VLC command: ${command}`);
      
      // Simulate a backend call
      const response = await fetch('/api/vlc-command', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ command })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to send command: ${response.statusText}`);
      }
      
      const result = await response.json();
      return result.response;
    } catch (error) {
      console.error(`Error sending command: ${error.message}`);
      showAlert(`Error: ${error.message}`, 'danger');
      return null;
    }
  }, []);

  // Function to launch VLC
  const launchVLC = useCallback(async () => {
    if (!mediaFile) {
      showAlert('Please upload a media file first', 'danger');
      return;
    }

    try {
      // Make API call to backend to launch VLC
      const response = await fetch('/api/launch-vlc', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ mediaPath: mediaFile })
      });

      if (!response.ok) {
        throw new Error(`Failed to launch VLC: ${response.statusText}`);
      }

      const result = await response.json();
      
      if (result.success) {
        setVlcConnected(true);
        setStatus('Ready');
        showAlert('VLC launched successfully', 'success');
        
        // Pause immediately after launch
        await sendVLCCommand('pause');
        setIsPlaying(false);
      } else {
        throw new Error(result.message);
      }
    } catch (error) {
      console.error(`Error launching VLC: ${error.message}`);
      showAlert(`Error launching VLC: ${error.message}`, 'danger');
      setStatus('Error');
    }
  }, [mediaFile, sendVLCCommand]);

  // Helper to show alert messages
  const showAlert = (message, type = 'info') => {
    setAlertMessage(message);
    setAlertType(type);
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
      setAlertMessage(null);
    }, 3000);
  };

  // Play/Pause toggle
  const togglePlayPause = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('pause');
      const newPlayingState = !isPlaying;
      setIsPlaying(newPlayingState);
      setStatus(newPlayingState ? 'Playing' : 'Paused');
      showAlert(newPlayingState ? 'Media playing' : 'Media paused');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: newPlayingState });
      }
    } catch (error) {
      console.error(`Error toggling play/pause: ${error.message}`);
    }
  }, [vlcConnected, isPlaying, sendVLCCommand, onStatusChange]);

  // Stop playback
  const stopPlayback = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      // First pause then seek to beginning
      await sendVLCCommand('pause');
      await sendVLCCommand('seek 0');
      setIsPlaying(false);
      setStatus('Stopped');
      showAlert('Media stopped');
      
      // Notify parent component
      if (onStatusChange) {
        onStatusChange({ isPlaying: false });
      }
    } catch (error) {
      console.error(`Error stopping playback: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand, onStatusChange]);

  // Seek backward/forward
  const seekMedia = useCallback(async (seconds) => {
    if (!vlcConnected) return;
    
    try {
      const command = `seek ${seconds > 0 ? '+' : ''}${seconds}`;
      await sendVLCCommand(command);
      showAlert(`Jumped ${seconds > 0 ? 'forward' : 'backward'} ${Math.abs(seconds)} seconds`);
    } catch (error) {
      console.error(`Error seeking media: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Volume up/down
  const adjustVolume = useCallback(async (amount) => {
    if (!vlcConnected) return;
    
    try {
      const command = amount > 0 ? 'volup 5' : 'voldown 5';
      await sendVLCCommand(command);
      showAlert(`Volume ${amount > 0 ? 'increased' : 'decreased'}`);
    } catch (error) {
      console.error(`Error adjusting volume: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Toggle fullscreen
  const toggleFullscreen = useCallback(async () => {
    if (!vlcConnected) return;
    
    try {
      await sendVLCCommand('fullscreen');
      showAlert('Toggled fullscreen mode');
    } catch (error) {
      console.error(`Error toggling fullscreen: ${error.message}`);
    }
  }, [vlcConnected, sendVLCCommand]);

  // Effect to handle active region changes
  useEffect(() => {
    if (!vlcConnected || !activeRegion || !wavesurferInstance) return;
    
    const handleRegionPlayback = async () => {
      try {
        // Seek to the region start time
        const startTime = activeRegion.start;
        await sendVLCCommand(`seek ${Math.floor(startTime)}`);
        
        // Resume playback if paused
        if (!isPlaying) {
          await sendVLCCommand('pause'); // VLC uses the same command to toggle play/pause
          setIsPlaying(true);
          setStatus('Playing region');
          
          // Notify parent component
          if (onStatusChange) {
            onStatusChange({ isPlaying: true });
          }
        }
      } catch (error) {
        console.error(`Error handling region playback: ${error.message}`);
      }
    };
    
    handleRegionPlayback();
  }, [activeRegion, vlcConnected, sendVLCCommand, wavesurferInstance, isPlaying, onStatusChange]);

  // Render VLC controller buttons
  return (
    <div className="vlc-controls">
      {/* Launch VLC Button */}
      <button 
        className="vlc-launch"
        onClick={launchVLC}
        disabled={!mediaFile || vlcConnected}
      >
        <i className="fas fa-external-link-alt"></i> Launch VLC
      </button>
      
      {/* VLC Playback Controls */}
      <div className={`vlc-playback-controls ${!vlcConnected ? 'disabled' : ''}`}>
        <button
          onClick={togglePlayPause}
          disabled={!vlcConnected}
          title={isPlaying ? 'Pause' : 'Play'}
        >
          <i className={`fas ${isPlaying ? 'fa-pause' : 'fa-play'}`}></i>
        </button>
        
        <button
          onClick={stopPlayback}
          disabled={!vlcConnected}
          title="Stop"
        >
          <i className="fas fa-stop"></i>
        </button>
        
        <button
          onClick={() => adjustVolume(-5)}
          disabled={!vlcConnected}
          title="Volume Down"
        >
          <i className="fas fa-volume-down"></i>
        </button>
        
        <button
          onClick={() => adjustVolume(5)}
          disabled={!vlcConnected}
          title="Volume Up"
        >
          <i className="fas fa-volume-up"></i>
        </button>
        
        <button
          onClick={() => seekMedia(-10)}
          disabled={!vlcConnected}
          title="Seek Backward 10s"
        >
          <i className="fas fa-backward"></i>
        </button>
        
        <button
          onClick={() => seekMedia(10)}
          disabled={!vlcConnected}
          title="Seek Forward 10s"
        >
          <i className="fas fa-forward"></i>
        </button>
        
        <button
          onClick={toggleFullscreen}
          disabled={!vlcConnected}
          title="Toggle Fullscreen"
        >
          <i className="fas fa-expand"></i>
        </button>
        
        <div className="vlc-status">
          <span className="status-label">VLC Status:</span>
          <span className={`status-value ${status.toLowerCase()}`}>{status}</span>
        </div>
      </div>
      
      {/* Alert message */}
      {alertMessage && (
        <div className={`vlc-alert alert-${alertType}`}>
          {alertMessage}
        </div>
      )}
    </div>
  );
};

export default VLCController;

================================================================================
File: src/components/WaveSurferComponent.js
================================================================================

/**
 * File: src/components/WaveSurferComponent.js
 * Description: WaveSurfer component using the official @wavesurfer/react hook
 * 
 * Version History:
 * v1.0.0 (2025-05-19) - Implementation using @wavesurfer/react
 * v1.0.1 (2025-05-19) - Fixed loading spinner and plugin issues
 * v1.0.2 (2025-05-19) - Fixed infinite update loop and duplicate plugins
 * v1.0.3 (2025-05-19) - Fixed zoom error, region looping and drag selection issues
 * v1.0.4 (2025-05-19) - Performance optimizations and infinite loop fixes
 */

import React, { useRef, useState, useEffect, useCallback } from 'react';
import { useWavesurfer } from '@wavesurfer/react';
import '../assets/styles/main.css';

// Optimization to prevent unnecessary renders
const isEqual = (prev, next) => {
  // Check if the audioFile, isPlaying, loopRegions, zoomLevel, and playbackSpeed are the same
  return (
    prev.audioFile === next.audioFile &&
    prev.isPlaying === next.isPlaying &&
    prev.loopRegions === next.loopRegions &&
    prev.zoomLevel === next.zoomLevel &&
    prev.playbackSpeed === next.playbackSpeed
  );
};

const WaveSurferComponent = ({ 
  audioFile, 
  isPlaying, 
  loopRegions,
  zoomLevel,
  playbackSpeed,
  onPlayPause, 
  onReady,
  onRegionActivated
}) => {
  // Refs
  const containerRef = useRef(null);
  const minimapRef = useRef(null);
  const pluginsInitializedRef = useRef(false);
  const regionsPluginRef = useRef(null);
  const activeRegionRef = useRef(null);
  
  // State
  const [loading, setLoading] = useState(true);
  const [isAudioLoaded, setIsAudioLoaded] = useState(false);
  const [audioUrl, setAudioUrl] = useState(null);
  
  // State for time display with reduced updates
  const [displayTime, setDisplayTime] = useState('00:00');
  const [displayDuration, setDisplayDuration] = useState('00:00');
  
  // Show loading spinner immediately when audio file changes
  useEffect(() => {
    if (audioFile) {
      setLoading(true);
      setIsAudioLoaded(false);
      // Reset plugins initialized flag when audio changes
      pluginsInitializedRef.current = false;
      // Reset active region when audio changes
      activeRegionRef.current = null;
    }
  }, [audioFile]);
  
  // Convert File to URL if needed
  useEffect(() => {
    if (audioFile) {
      if (audioFile instanceof File) {
        const url = URL.createObjectURL(audioFile);
        setAudioUrl(url);
        
        // Clean up URL when component unmounts or audio changes
        return () => {
          URL.revokeObjectURL(url);
        };
      } else {
        setAudioUrl(audioFile);
      }
    } else {
      setAudioUrl(null);
    }
  }, [audioFile]);
  
  // Initialize WaveSurfer with useWavesurfer hook (with options to prevent infinite updates)
  const { wavesurfer, isReady } = useWavesurfer({
    container: containerRef,
    height: 180,
    waveColor: '#b8b8b8',
    progressColor: '#08c3f2',
    cursorColor: '#ff5722',
    cursorWidth: 2,
    minPxPerSec: 100, // Start with default zoom - will update later
    url: audioUrl,
    normalize: true,
    autoScroll: true,
    autoCenter: true,
  });
  
  // Safe access to regions plugin
  const getRegionsPlugin = useCallback(() => {
    if (!wavesurfer) return null;
    
    // First try direct reference
    if (regionsPluginRef.current) return regionsPluginRef.current;
    
    // Then try through wavesurfer
    if (wavesurfer.regions) return wavesurfer.regions;
    
    // Finally try to find in plugins
    const plugins = wavesurfer.getActivePlugins();
    const regionsPlugin = plugins.find(plugin => 
      plugin.name === 'regions' || plugin.name === 'Regions' || 
      (plugin.constructor && plugin.constructor.name === 'RegionsPlugin')
    );
    
    // Store for future use if found
    if (regionsPlugin) {
      regionsPluginRef.current = regionsPlugin;
      // Also expose on wavesurfer for external access
      wavesurfer.regions = regionsPlugin;
    }
    
    return regionsPlugin;
  }, [wavesurfer]);
  
  // Reset region color handler
  const resetRegionColors = useCallback(() => {
    const regionsPlugin = getRegionsPlugin();
    if (!regionsPlugin) return;
    
    try {
      const allRegions = regionsPlugin.getRegions();
      Object.values(allRegions).forEach((region) => {
        if (region.id !== (activeRegionRef.current?.id)) {
          region.setOptions({ color: 'rgba(0,0,255,0.4)' });
        }
      });
    } catch (error) {
      console.error("Error resetting region colors:", error);
    }
  }, [getRegionsPlugin]);
  
  // Handle region in event - simplified to match HTML implementation
  const handleRegionIn = useCallback((region) => {
    console.log('region-in', region.id, 'loopRegions:', loopRegions);
    
    // Set as active region
    activeRegionRef.current = region;
    
    // Highlight active region
    try {
      region.setOptions({ color: 'rgba(0,255,0,0.2)' });
    } catch (error) {
      console.error("Error highlighting region:", error);
    }
  }, []);
  
  // Handle region out event - simplified to match HTML implementation
  const handleRegionOut = useCallback((region) => {
    console.log('region-out', region.id, 'loopRegions:', loopRegions);
    
    // Check if this is the active region 
    if (region.id === activeRegionRef.current?.id) {
      if (loopRegions) {
        // If looping is enabled, replay the region
        try {
          region.play();
        } catch (error) {
          console.error("Error replaying region:", error);
        }
      } else {
        // If not looping, clear the active region
        console.log('Not looping, continuing playback');
        region.setOptions({ color: 'rgba(0,0,255,0.4)' });
        activeRegionRef.current = null;
      }
    }
  }, [loopRegions]);
  
  // Handle region click event - simplified to match HTML implementation
  const handleRegionClick = useCallback((region, e) => {
    console.log('Region clicked!', region);
    try {
      e.stopPropagation(); // prevent triggering a click on the waveform
      
      // Set this as the active region
      activeRegionRef.current = region;
      
      // Reset all regions to default color except the clicked one
      resetRegionColors();
      
      // Set this region to active color
      region.setOptions({ color: 'rgba(0,255,0,0.2)' });
      
      // Play the region
      region.play();
      
      // Update parent component play state
      if (onPlayPause) {
        onPlayPause(true);
      }
      
      // Notify parent about region activation
      if (props.onRegionActivated) {
        props.onRegionActivated(region);
      }
    } catch (error) {
      console.error("Error handling region click:", error);
    }
  }, [resetRegionColors, onPlayPause, props]);
  
  // Handle region update end - simplified
  const handleRegionUpdateEnd = useCallback((region) => {
    console.log('region-update-end', region.id);
    
    // Auto-select the newly created/updated region
    activeRegionRef.current = region;
    
    // Reset all region colors
    resetRegionColors();
    
    // Set this region to active color
    region.setOptions({ color: 'rgba(0,255,0,0.2)' });
  }, [resetRegionColors]);
  
  // Handle waveform click - simplified to match HTML implementation
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const handleWaveformClick = useCallback(() => {
    // Reset active region when clicking on the waveform (outside any region)
    activeRegionRef.current = null;
  }, []);
  
  // Direct method to create a region programmatically - simplified
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const createRegion = useCallback((start, end) => {
    const regionsPlugin = getRegionsPlugin();
    if (!regionsPlugin) return null;
    
    try {
      const region = regionsPlugin.addRegion({
        start: start,
        end: end,
        color: 'rgba(0,0,255,0.4)',
        drag: true,
        resize: true
      });
      
      console.log("Region created:", region);
      return region;
    } catch (error) {
      console.error("Failed to create region:", error);
      return null;
    }
  }, [getRegionsPlugin]);
  
  // Update loading state - fix the infinite update loop
  // eslint-disable-next-line react-hooks/exhaustive-deps
  useEffect(() => {
    if (isReady && !isAudioLoaded) {
      console.log("Setting audio loaded");
      setLoading(false);
      setIsAudioLoaded(true);
      
      // Notify parent component that wavesurfer is ready
      if (onReady) {
        onReady(wavesurfer);
      }
    }
  }, [isReady]);
  
  // Update time display less frequently
  useEffect(() => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    // Update time display every 500ms instead of every frame
    const interval = setInterval(() => {
      try {
        const currentTime = wavesurfer.getCurrentTime() || 0;
        const duration = wavesurfer.getDuration() || 0;
        setDisplayTime(formatTime(currentTime));
        setDisplayDuration(formatTime(duration));
      } catch (e) {
        // Ignore errors
      }
    }, 500);
    
    return () => clearInterval(interval);
  }, [wavesurfer, isReady, isAudioLoaded]);
  
  // Log loopRegions prop change
  useEffect(() => {
    console.log("[LOOP STATUS] loopRegions is now:", loopRegions);
  }, [loopRegions]);
  
  // Initialize plugins manually AFTER wavesurfer is ready
  useEffect(() => {
    // Early exit if not ready
    if (!wavesurfer || !isReady || !minimapRef.current) return;
    
    // Only run once per wavesurfer instance
    if (pluginsInitializedRef.current) {
      return;
    }
    
    console.log("Initializing plugins...");
    
    // Use an IIFE to prevent setState in an effect without dependencies
    (async () => {
      try {
        // Import plugins
        console.log("Importing WaveSurfer plugins...");
        const [
          { default: Timeline },
          { default: Spectrogram },
          { default: Regions },
          { default: Minimap },
          { default: Hover }
        ] = await Promise.all([
          import('wavesurfer.js/dist/plugins/timeline.js'),
          import('wavesurfer.js/dist/plugins/spectrogram.js'),
          import('wavesurfer.js/dist/plugins/regions.js'),
          import('wavesurfer.js/dist/plugins/minimap.js'),
          import('wavesurfer.js/dist/plugins/hover.js')
        ]);
        
        console.log("Creating plugins...");
        
        // Add Regions first (important for order of operations)
        const regionsPlugin = Regions.create({
          // Always enable drag selection (true is hardcoded since we removed the checkbox)
          dragSelection: true,
          color: 'rgba(0,0,255,0.4)',
        });
        wavesurfer.registerPlugin(regionsPlugin);
        
        // Store regions plugin reference
        regionsPluginRef.current = regionsPlugin;
        
        // Add Timeline
        const timelinePlugin = Timeline.create({
          height: 30,
          timeInterval: 1,
          primaryColor: '#ffffff',
          secondaryColor: '#aaaaaa',
          primaryFontColor: '#ffffff',
          secondaryFontColor: '#dddddd',
        });
        wavesurfer.registerPlugin(timelinePlugin);
        
        // Add Spectrogram
        const spectrogramPlugin = Spectrogram.create({
          labels: true,
          height: 350,
          splitChannels: false,
          colorMap: 'roseus',
          frequencyMax: 8000,
          frequencyMin: 0,
          fftSamples: 512,
          noverlap: 0,
        });
        wavesurfer.registerPlugin(spectrogramPlugin);
        
        // Add Hover
        const hoverPlugin = Hover.create({
          lineColor: '#ff5722',
          lineWidth: 2,
          labelBackground: '#111111',
          labelColor: '#ffffff',
        });
        wavesurfer.registerPlugin(hoverPlugin);
        
        // Add Minimap
        const minimapPlugin = Minimap.create({
          container: minimapRef.current,
          height: 40,
          waveColor: '#b8b8b8',
          progressColor: '#08c3f2',
        });
        wavesurfer.registerPlugin(minimapPlugin);
        
        // Add waveform click handler - use the correct method based on wavesurfer version
        wavesurfer.on('interaction', handleWaveformClick);
        
        // Add event listeners directly 
        if (regionsPlugin) {
          // Add event listeners
          regionsPlugin.on('region-in', handleRegionIn);
          regionsPlugin.on('region-out', handleRegionOut);
          regionsPlugin.on('region-clicked', handleRegionClick);
          regionsPlugin.on('region-update-end', handleRegionUpdateEnd);
          
          // Ensure the plugin is correctly exposed for external access
          if (!wavesurfer.regions && regionsPlugin) {
            // Add a direct reference to make clearing regions easier
            wavesurfer.regions = regionsPlugin;
          }
        }
        
        // Mark as initialized
        pluginsInitializedRef.current = true;
        
        console.log("Plugins initialized successfully");
      } catch (error) {
        console.error("Error initializing plugins:", error);
      }
    })();
    
    // Cleanup function for when component unmounts
    return () => {
      if (wavesurfer) {
        wavesurfer.un('interaction');
      }
    };
  // eslint-disable-next-line react-hooks/exhaustive-deps  
  }, [
    wavesurfer, 
    isReady, 
    handleWaveformClick, 
    handleRegionIn, 
    handleRegionOut, 
    handleRegionClick, 
    handleRegionUpdateEnd
  ]);
  
  // Handle play/pause
  useEffect(() => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    try {
      const wsIsPlaying = wavesurfer.isPlaying();
      
      if (isPlaying && !wsIsPlaying) {
        wavesurfer.play();
      } else if (!isPlaying && wsIsPlaying) {
        wavesurfer.pause();
      }
    } catch (error) {
      console.error("Error updating playback status:", error);
    }
  }, [isPlaying, wavesurfer, isReady, isAudioLoaded]);
  
  // Safe zoom function - prevent errors
  const safeZoom = useCallback((level) => {
    if (!wavesurfer || !isReady || !isAudioLoaded) return;
    
    try {
      wavesurfer.zoom(level);
    } catch (error) {
      console.warn("Zoom error - audio may not be fully loaded yet:", error);
    }
  }, [wavesurfer, isReady, isAudioLoaded]);
  
  // Update zoom level - but only after audio is fully loaded
  useEffect(() => {
    if (isAudioLoaded && isReady && wavesurfer) {
      // Use a small timeout to ensure audio is fully processed
      const zoomTimer = setTimeout(() => {
        safeZoom(zoomLevel);
      }, 100);
      
      return () => clearTimeout(zoomTimer);
    }
  }, [zoomLevel, isAudioLoaded, isReady, wavesurfer, safeZoom]);
  
  // Update playback speed
  useEffect(() => {
    if (wavesurfer && isReady && isAudioLoaded && playbackSpeed) {
      try {
        wavesurfer.setPlaybackRate(playbackSpeed);
      } catch (error) {
        console.error("Error setting playback speed:", error);
      }
    }
  }, [playbackSpeed, wavesurfer, isReady, isAudioLoaded]);
  
  // Helper function to format time in MM:SS
  const formatTime = (seconds) => {
    if (!seconds && seconds !== 0) return '--:--';
    const min = Math.floor(seconds / 60);
    const sec = Math.floor(seconds % 60);
    return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
  };
  
  return (
    <div className="waveform-wrapper">
      {/* Single container for waveform, spectrogram and timeline */}
      <div id="waveform-container" ref={containerRef} style={{
        width: '100%',
        marginBottom: '20px',
        backgroundColor: '#1a1a1a',
        borderRadius: '5px',
        boxShadow: '0 4px 10px rgba(0, 0, 0, 0.3)',
        position: 'relative',
        height: '560px',
        overflow: 'visible'
      }}>
        {/* Loading spinner overlay */}
        {loading && (
          <div id="spectrogram-loading" className="loading-container">
            <div className="simple-spinner"></div>
            <div className="loading-text">Loading Audio...</div>
          </div>
        )}
        
        {/* Message when no audio is loaded */}
        {!loading && !isAudioLoaded && (
          <div style={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            textAlign: 'center',
            color: '#6c757d'
          }}>
            <div style={{ fontSize: '3rem', marginBottom: '1rem' }}>
              <i className="fas fa-music"></i>
            </div>
            <h3>No Audio Loaded</h3>
            <p>Upload an audio file to visualize the waveform and spectrogram.</p>
          </div>
        )}
      </div>
      
      {/* Minimap for navigation - separate container */}
      <div id="minimap" ref={minimapRef}></div>
      
      {/* Display current time (optional) - using cached values */}
      {isReady && isAudioLoaded && (
        <div className="current-time" style={{ textAlign: 'center', marginBottom: '10px' }}>
          Time: {displayTime} / {displayDuration}
        </div>
      )}
    </div>
  );
};

// Export with React.memo to prevent unnecessary re-renders
export default React.memo(WaveSurferComponent, isEqual);

================================================================================
File: src/index.js
================================================================================

/**
 * File: src/index.js
 * Description: Application entry point
 * 
 * Version History:
 * v1.0.0 (2025-05-18) - Initial implementation
 * v1.0.1 (2025-05-19) - Added error handling and version logging
 * v1.0.2 (2025-05-19) - Fixed ESLint warning about unused import
 */

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './app';

// Add global error handler to catch unhandled errors
window.addEventListener('error', (event) => {
  console.error('Uncaught runtime error:', event.error);
});

// Log the React version to verify
console.log("React version:", React.version);

// Create root and render app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
